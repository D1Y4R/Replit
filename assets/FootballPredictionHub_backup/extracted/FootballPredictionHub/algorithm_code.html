<html><head><title>Football Prediction Algorithm Code</title><style>pre {background-color: #f5f5f5; padding: 10px; overflow: auto;}</style></head><body>
<h1>main.py</h1><pre>
import logging
import os
import requests
from datetime import datetime, timedelta
import pytz
from flask import Flask, render_template, jsonify, request, flash
from match_prediction import MatchPredictor

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET")

# Tahmin modelini oluştur
predictor = MatchPredictor()

def get_matches(selected_date=None):
    try:
        # Create timezone objects
        utc = pytz.UTC
        turkey_tz = pytz.timezone('Europe/Istanbul')

        if not selected_date:
            selected_date = datetime.now().strftime('%Y-%m-%d')

        matches = []
        api_key = 'a22a240805f36f83e9ee99f094c9f204090678820a3eba2f6447c099a380a583'

        # Get matches from APIFootball
        url = "https://apiv3.apifootball.com/"
        params = {
            'action': 'get_events',
            'APIkey': api_key,
            'from': selected_date,
            'to': selected_date,
            'timezone': 'Europe/Istanbul'
        }
        logger.info(f"Sending API request to {url} with params: {params}")

        logger.info(f"Fetching matches for date: {selected_date}")
        response = requests.get(url, params=params)
        logger.debug(f"API Response status: {response.status_code}")
        logger.debug(f"API Response content: {response.content}") # Added logging for debugging

        if response.status_code == 200:
            data = response.json()
            logger.info(f"API response received. Type: {type(data)}")
            if data == []:
                logger.warning("API returned empty data array")

            if isinstance(data, list):
                logger.info(f"Total matches in API response: {len(data)}")
                for match in data:
                    match_obj = process_match(match, utc, turkey_tz)
                    if match_obj:
                        matches.append(match_obj)
                        logger.debug(f"Added match: {match_obj['competition']['name']} - {match_obj['homeTeam']['name']} vs {match_obj['awayTeam']['name']}")
            elif isinstance(data, dict):
                logger.error(f"API returned error: {data.get('message', 'Unknown error')}")

        # Group matches by league
        league_matches = {}
        for match in matches:
            league_id = match['competition']['id']
            league_name = match['competition']['name']

            if league_id not in league_matches:
                league_matches[league_id] = {
                    'name': league_name,
                    'matches': []
                }
            league_matches[league_id]['matches'].append(match)

        # Sort matches within each league
        for league_data in league_matches.values():
            league_data['matches'].sort(key=lambda x: (
                0 if x['is_live'] else (1 if x['status'] == 'FINISHED' else 2),
                x['turkish_time']
            ))

        # Format leagues for template
        formatted_leagues = []
        for league_id, league_data in league_matches.items():
            formatted_leagues.append({
                'id': league_id,
                'name': league_data['name'],
                'matches': league_data['matches'],
                'priority': get_league_priority(league_id)
            })

        # Sort leagues by priority (high to low) and then by name
        formatted_leagues.sort(key=lambda x: (-x['priority'], x['name']))

        logger.info(f"Total leagues found: {len(formatted_leagues)}")
        for league in formatted_leagues:
            logger.info(f"League: {league['name']} - {len(league['matches'])} matches")

        return {'leagues': formatted_leagues}

    except Exception as e:
        logger.error(f"Error fetching matches: {str(e)}")
        return {'leagues': []}

def get_league_priority(league_id):
    """Return priority for league sorting. Higher number means higher priority."""

    # Convert league_id to string for comparison
    league_id_str = str(league_id)

    # Favorite leagues with their IDs from API-Football
    favorite_leagues = {
        "3": 100,    # UEFA Champions League
        "4": 90,     # UEFA Europa League
        "683": 80,   # UEFA Conference League
        "302": 70,   # La Liga
        "152": 65,   # Premier League
        "207": 60,   # Serie A
        "175": 55,   # Bundesliga
        "168": 50,   # Ligue 1
        "322": 45,   # Türk Süper Lig
        "266": 25,   # Primeira Liga
        "128": 40,   # Gana Premier Lig
        "567": 39,   # Brezilya Série A
        "164": 38,   # Hollanda Eredivisie
        "358": 37,   # Arjantin Primera División
        "196": 36,   # İskoçya Premiership
        "179": 35,   # İsviçre Süper Ligi
        "144": 34,   # Belçika Pro League
        "182": 33    # Portekiz Primeira Liga
    }

    # Doğrudan ID ile kontrol et
    if league_id_str in favorite_leagues:
        return favorite_leagues[league_id_str]

    return 0

def process_match(match, utc, turkey_tz):
    try:
        # Get team names
        home_name = match.get('match_hometeam_name', '')
        away_name = match.get('match_awayteam_name', '')

        if not home_name or not away_name:
            return None

        # Get match time and convert to Turkish time
        match_date = match.get('match_date', '')
        match_time = match.get('match_time', '')
        league_name = match.get('league_name', '')

        # Log raw API response for debugging
        logger.info(f"Raw API match data for {home_name} vs {away_name}:")
        logger.info(f"Match date: {match_date}")
        logger.info(f"Match time: {match_time}")

        turkish_time_str = "Belirlenmedi"
        try:
            if match_date and match_time and match_time != "00:00":
                # API'den gelen zamanı doğrudan kullan, çünkü params 'timezone': 'Europe/Istanbul' zaten ayarlanmış
                turkish_time_str = match_time
                
                logger.info(f"Time conversion details for {home_name} vs {away_name}:")
                logger.info(f"Original time (from API): {match_time}")
                logger.info(f"Using as Turkish time (TSİ): {turkish_time_str}")

        except ValueError as e:
            logger.error(f"Time conversion error: {e}")
            logger.error(f"Input date={match_date}, time={match_time}")

        # Get match status and scores
        match_status = match.get('match_status', '')
        match_live = match.get('match_live', '0')
        home_score = '0'
        away_score = '0'
        is_live = False
        live_minute = ''

        if match_status == 'Finished':
            home_score = match.get('match_hometeam_score', '0')
            away_score = match.get('match_awayteam_score', '0')
            is_live = False
        elif match_live == '1' or match_status in ['LIVE', 'HALF TIME BREAK', 'PENALTY IN PROGRESS']:
            home_score = match.get('match_hometeam_score', '0')
            away_score = match.get('match_awayteam_score', '0')
            is_live = True
            if match_status.isdigit():
                live_minute = match_status

        return {
            'competition': {
                'id': match.get('league_id', ''),
                'name': match.get('league_name', '')
            },
            'utcDate': match_date,
            'status': 'LIVE' if is_live else ('FINISHED' if match_status == 'Finished' else 'SCHEDULED'),
            'homeTeam': {
                'name': home_name,
                'id': match.get('match_hometeam_id', '')
            },
            'awayTeam': {
                'name': away_name,
                'id': match.get('match_awayteam_id', '')
            },
            'score': {
                'fullTime': {
                    'home': int(home_score) if home_score.isdigit() else 0,
                    'away': int(away_score) if away_score.isdigit() else 0
                }
            },
            'turkish_time': turkish_time_str,
            'is_live': is_live,
            'live_minute': live_minute
        }

    except Exception as e:
        logger.error(f"Error processing match: {str(e)}")
        return None

@app.route('/')
def index():
    selected_date = request.args.get('date', datetime.now().strftime('%Y-%m-%d'))
    matches_data = get_matches(selected_date)
    return render_template('index.html', matches=matches_data, selected_date=selected_date)

@app.route('/api/team-stats/<team_id>')
def team_stats(team_id):
    try:
        # APIFootball API anahtarı
        api_key = 'a22a240805f36f83e9ee99f094c9f204090678820a3eba2f6447c099a380a583'

        # Son 6 aylık maçları al
        end_date = datetime.now()
        start_date = end_date - timedelta(days=180)  # 6 ay öncesine kadar maçları al

        # APIFootball'dan takımın son maçlarını al
        url = "https://apiv3.apifootball.com/"
        params = {
            'action': 'get_events',
            'from': start_date.strftime('%Y-%m-%d'),
            'to': end_date.strftime('%Y-%m-%d'),
            'team_id': team_id,
            'APIkey': api_key
        }

        logger.debug(f"Fetching team stats for team_id: {team_id}")
        response = requests.get(url, params=params)
        logger.debug(f"API Response status: {response.status_code}")

        if response.status_code == 200:
            matches = response.json()
            logger.debug(f"Total matches found: {len(matches)}")

            # Maçları tarihe göre sırala (en yeniden en eskiye)
            matches.sort(key=lambda x: x.get('match_date', ''), reverse=True)

            # Son 5 maçı al ve formatla
            last_5_matches = []
            for match in matches[:5]:  # Son 5 maç
                match_date = match.get('match_date', '')
                try:
                    # Tarihi düzgün formata çevir
                    date_obj = datetime.strptime(match_date, '%Y-%m-%d')
                    formatted_date = date_obj.strftime('%d.%m.%Y')
                except ValueError:
                    formatted_date = match_date

                match_data = {
                    'date': formatted_date,
                    'match': f"{match.get('match_hometeam_name', '')} vs {match.get('match_awayteam_name', '')}",
                    'score': f"{match.get('match_hometeam_score', '0')} - {match.get('match_awayteam_score', '0')}"
                }
                last_5_matches.append(match_data)

            return jsonify(last_5_matches)

        return jsonify([])

    except Exception as e:
        logger.error(f"Error fetching team stats: {str(e)}")
        return jsonify([])


def get_league_standings(league_id):
    """Get standings for a specific league"""
    try:
        logger.info(f"Attempting to fetch standings for league_id: {league_id}")

        api_key = os.environ.get('FOOTBALL_DATA_API_KEY')
        if not api_key:
            logger.error("FOOTBALL_DATA_API_KEY is not set")
            return None

        # Football-data.org API endpoint
        url = f"https://api.football-data.org/v4/competitions/{league_id}/standings"
        headers = {'X-Auth-Token': api_key}

        logger.info(f"Making API request to {url}")
        response = requests.get(url, headers=headers)

        # Yanıt başlıklarını kontrol et
        logger.info(f"API Response headers: {response.headers}")

        # Yanıt içeriğini kontrol et
        try:
            data = response.json()
            logger.info(f"API Response data: {data}")
        except Exception as e:
            logger.error(f"Error parsing JSON response: {e}")
            return None

        if response.status_code != 200:
            logger.error(f"API request failed with status code: {response.status_code}")
            logger.error(f"Error message: {data.get('message', 'No error message provided')}")
            return None

        if 'standings' not in data:
            logger.error("API response doesn't contain standings data")
            logger.error(f"Full response: {data}")
            return None

        standings = []
        for standing_type in data['standings']:
            if standing_type['type'] == 'TOTAL':  # Ana puan durumu
                for team in standing_type['table']:
                    team_data = {
                        'rank': team['position'],
                        'name': team['team']['name'],
                        'logo': team['team']['crest'],
                        'played': team['playedGames'],
                        'won': team['won'],
                        'draw': team['draw'],
                        'lost': team['lost'],
                        'goals_for': team['goalsFor'],
                        'goals_against': team['goalsAgainst'],
                        'goal_diff': team['goalDifference'],
                        'points': team['points']
                    }
                    standings.append(team_data)
                break

        if not standings:
            logger.error("No standings data was processed")
            return None

        logger.info(f"Successfully processed standings data. Found {len(standings)} teams.")
        return standings

    except Exception as e:
        logger.error(f"Error in get_league_standings: {str(e)}")
        logger.exception("Full traceback:")
        return None

def get_available_leagues():
    """Get list of available leagues"""
    return [
        {'id': 2021, 'name': 'Premier League'},
        {'id': 2014, 'name': 'La Liga'},
        {'id': 2019, 'name': 'Serie A'},
        {'id': 2002, 'name': 'Bundesliga'},
        {'id': 2015, 'name': 'Ligue 1'}
    ]

@app.route('/leagues')
def leagues():
    try:
        # league_id'yi GET parametresinden al
        league_id = request.args.get('league_id', type=int)  # Changed back to int for new IDs
        logger.info(f"Received request for /leagues with league_id: {league_id}")

        available_leagues = get_available_leagues()
        logger.info(f"Available leagues: {available_leagues}")

        selected_league_name = None
        standings = None

        if league_id:
            logger.info(f"Processing request for league_id: {league_id}")

            # Find selected league name
            for league in available_leagues:
                if league['id'] == league_id:
                    selected_league_name = league['name']
                    logger.info(f"Found matching league: {selected_league_name}")
                    break

            if not selected_league_name:
                logger.error(f"No matching league found for league_id: {league_id}")
                flash("Seçtiğiniz lig için puan durumu verisi şu anda mevcut değil.", "error")
                return render_template('leagues.html',
                                    available_leagues=available_leagues,
                                    selected_league=None,
                                    selected_league_name=None,
                                    standings=None)

            # Get standings for selected league
            standings = get_league_standings(league_id)

            if standings is None:
                logger.error(f"Failed to fetch standings for league: {selected_league_name} (ID: {league_id})")
                flash("Puan durumu verisi alınamadı. Lütfen daha sonra tekrar deneyin.", "error")
            else:
                logger.info(f"Successfully fetched standings for {selected_league_name}")

        return render_template('leagues.html',
                            available_leagues=available_leagues,
                            selected_league=league_id,
                            selected_league_name=selected_league_name,
                            standings=standings)

    except Exception as e:
        logger.error(f"Unexpected error in leagues route: {str(e)}")
        logger.exception("Full traceback:")
        flash("Bir hata oluştu. Lütfen daha sonra tekrar deneyin.", "error")
        return render_template('leagues.html',
                            available_leagues=get_available_leagues(),
                            selected_league=None,
                            selected_league_name=None,
                            standings=None)

@app.route('/api/predict-match/<home_team_id>/<away_team_id>')
def predict_match(home_team_id, away_team_id):
    """Belirli bir maç için tahmin yap"""
    try:
        # Takım adlarını alın
        home_team_name = request.args.get('home_name', 'Ev Sahibi')
        away_team_name = request.args.get('away_name', 'Deplasman')
        force_update = request.args.get('force_update', 'false').lower() == 'true'

        # Takım ID'lerini doğrula
        if not home_team_id or not away_team_id or not home_team_id.isdigit() or not away_team_id.isdigit():
            return jsonify({"error": "Geçersiz takım ID'leri"}), 400
        
        try:
            # Tahmin yap
            prediction = predictor.predict_match(home_team_id, away_team_id, home_team_name, away_team_name, force_update)

            if not prediction:
                return jsonify({"error": "Tahmin yapılamadı, takım verileri eksik olabilir", 
                               "match": f"{home_team_name} vs {away_team_name}"}), 400
                
            # Tahmin hata içeriyorsa
            if isinstance(prediction, dict) and "error" in prediction:
                return jsonify(prediction), 400

            # Maksimum yanıt boyutu kontrolü - büyük tahmin verilerinde hata olmasını önle
            import json
            response_size = len(json.dumps(prediction))
            
            if response_size > 1000000:  # 1MB'dan büyükse
                logger.warning(f"Çok büyük yanıt boyutu: {response_size} byte. Gereksiz detaylar kırpılıyor.")
                # Bazı gereksiz alanları kırp
                if 'home_team' in prediction and 'form' in prediction['home_team']:
                    # Form detaylarını azalt
                    prediction['home_team']['form'].pop('detailed_data', None)
                    prediction['home_team'].pop('form_periods', None)
                
                if 'away_team' in prediction and 'form' in prediction['away_team']:
                    # Form detaylarını azalt
                    prediction['away_team']['form'].pop('detailed_data', None)
                    prediction['away_team'].pop('form_periods', None)
                
                if 'predictions' in prediction and 'raw_metrics' in prediction['predictions']:
                    # Raw metrikleri kaldır
                    prediction['predictions'].pop('raw_metrics', None)

            return jsonify(prediction)
        except Exception as predict_error:
            logger.error(f"Tahmin işlemi sırasında hata: {str(predict_error)}")
            import traceback
            logger.error(traceback.format_exc())
            
            # Daha basit bir yanıt dön - veri boyutu nedenli hatalar için
            return jsonify({
                "error": "Tahmin işlemi sırasında teknik bir hata oluştu, lütfen daha sonra tekrar deneyin",
                "match": f"{home_team_name} vs {away_team_name}",
                "timestamp": datetime.now().timestamp()
            }), 500

    except Exception as e:
        logger.error(f"Tahmin yapılırken beklenmeyen hata: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({"error": "Sistem hatası. Lütfen daha sonra tekrar deneyin.", 
                        "match": f"{home_team_name} vs {away_team_name}"}), 500

@app.route('/api/clear-cache', methods=['POST'])
def clear_predictions_cache():
    """Tahmin önbelleğini temizle"""
    try:
        success = predictor.clear_cache()
        if success:
            return jsonify({"success": True, "message": "Önbellek temizlendi, yeni tahminler yapılabilir"})
        else:
            logger.warning("Önbellek temizleme işlemi başarısız oldu ancak işlem devam edebilir")
            return jsonify({"success": False, "message": "Önbellek temizlenirken bir sorun oluştu, ancak işlem devam edebilir"}), 200
    except Exception as e:
        error_msg = f"Önbellek temizlenirken beklenmeyen hata: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg, "success": False}), 500

@app.route('/predictions')
def predictions_page():
    """Tüm tahminleri gösteren sayfa"""
    return render_template('predictions.html')

@app.route('/cache-table')
def cache_table():
    """Önbellekteki tahminleri tabloda gösteren sayfa"""
    import json
    from tabulate import tabulate
    
    try:
        with open('predictions_cache.json', 'r', encoding='utf-8') as f:
            predictions = json.load(f)
        
        # Sonuçları saklamak için liste
        results = []
        
        # Tüm tahminleri dolaş
        for match_key, prediction in predictions.items():
            if 'home_team' not in prediction or 'away_team' not in prediction:
                continue
                
            home_name = prediction.get('home_team', {}).get('name', '')
            away_name = prediction.get('away_team', {}).get('name', '')
            match_name = f'{home_name} vs {away_name}'
            
            # Tahmin edilen skor
            exact_score = prediction.get('predictions', {}).get('betting_predictions', {}).get('exact_score', {}).get('prediction', 'N/A')
            
            # Gerçek sonucu bul
            actual_home_goals = None
            actual_away_goals = None
            actual_result = 'Henüz oynanmadı'
            
            # Ev sahibi takımın son maçlarında ara
            if 'home_team' in prediction and 'form' in prediction['home_team'] and 'recent_match_data' in prediction['home_team']['form']:
                for match in prediction['home_team']['form']['recent_match_data']:
                    if match.get('opponent') == away_name and match.get('is_home', False) and match.get('result') in ['W', 'D', 'L']:
                        actual_home_goals = match.get('goals_scored', 'N/A')
                        actual_away_goals = match.get('goals_conceded', 'N/A')
                        actual_result = f'{actual_home_goals}-{actual_away_goals}'
                        break
                        
            # Deplasman takımının son maçlarında ara
            if actual_result == 'Henüz oynanmadı' and 'away_team' in prediction and 'form' in prediction['away_team'] and 'recent_match_data' in prediction['away_team']['form']:
                for match in prediction['away_team']['form']['recent_match_data']:
                    if match.get('opponent') == home_name and not match.get('is_home', True) and match.get('result') in ['W', 'D', 'L']:
                        actual_away_goals = match.get('goals_scored', 'N/A')
                        actual_home_goals = match.get('goals_conceded', 'N/A')
                        actual_result = f'{actual_home_goals}-{actual_away_goals}'
                        break
            
            # Tahmin doğruluğunu kontrol et
            accuracy = 'Doğru' if exact_score == actual_result and actual_result != 'Henüz oynanmadı' else 'Yanlış' if actual_result != 'Henüz oynanmadı' else 'Henüz oynanmadı'
            
            # Ev sahibi ve deplasman takımlarının gol beklentileri
            expected_home = prediction.get('predictions', {}).get('expected_goals', {}).get('home', 'N/A')
            expected_away = prediction.get('predictions', {}).get('expected_goals', {}).get('away', 'N/A')
            expected_goals = f'{expected_home}-{expected_away}'
            
            # Tahmin tarihi
            date_predicted = prediction.get('date_predicted', 'Bilinmiyor')
            
            # Sonucu ekle
            results.append([match_name, exact_score, actual_result, expected_goals, accuracy, date_predicted])
                
        # Özet istatistikler hesapla
        completed_matches = [r for r in results if r[4] != 'Henüz oynanmadı']
        correct_predictions = [r for r in completed_matches if r[4] == 'Doğru']
        
        # İstatistikler
        total_matches = len(results)
        completed_count = len(completed_matches)
        correct_ratio = round(len(correct_predictions)/completed_count*100, 2) if completed_count > 0 else 0
        correct_count = len(correct_predictions)
        
        return render_template('cache_table.html', 
                              results=results, 
                              total_matches=total_matches, 
                              completed_count=completed_count, 
                              correct_ratio=correct_ratio, 
                              correct_count=correct_count)
    except FileNotFoundError:
        return render_template('cache_table.html', error="Önbellek dosyası (predictions_cache.json) bulunamadı.")
    except json.JSONDecodeError:
        return render_template('cache_table.html', error="Önbellek dosyası geçerli bir JSON formatında değil.")
    except Exception as e:
        return render_template('cache_table.html', error=f"Bir hata oluştu: {str(e)}")

if __name__ == '__main__':
    import socket
    
    def is_port_available(port):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(('localhost', port)) != 0
    
    # Get port from environment or use 5000 as default
    preferred_port = int(os.environ.get("PORT", 5000))
    port = preferred_port
    
    # Try preferred port first, if not available, find next available port
    if not is_port_available(port):
        print(f"Port {port} zaten kullanımda, alternatif port aranıyor...")
        for test_port in range(3000, 9000):
            if test_port != port and is_port_available(test_port):
                port = test_port
                break
    
    print(f"Uygulama {port} portunda başlatılıyor")
    # Use 0.0.0.0 to make the server publicly available
    try:
        app.run(host='0.0.0.0', port=port, debug=True)
    except Exception as e:
        print(f"Uygulama başlatılırken hata oluştu: {e}")
        # Try one more alternate port if all else fails
        alt_port = 8080 if port != 8080 else 3000
        print(f"Son çare: {alt_port} portu deneniyor...")
        app.run(host='0.0.0.0', port=alt_port, debug=True)</pre><h1>match_prediction.py</h1><pre>
import logging
import numpy as np
import json
import os
from datetime import datetime, timedelta
import requests
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.models import Sequential, load_model, save_model
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MatchPredictor:
    def __init__(self):
        self.api_key = 'a22a240805f36f83e9ee99f094c9f204090678820a3eba2f6447c099a380a583'
        self.predictions_cache = {}
        self.load_cache()

        # Bayesyen güncelleme için parametreler
        self.lig_ortalamasi_ev_gol = 1.5  # Ev sahibi takımların lig genelinde maç başına ortalama gol
        self.lig_ortalamasi_deplasman_gol = 1.2  # Deplasman takımlarının lig genelinde maç başına ortalama gol
        self.k_ev = 5  # Ev sahibi prior gücü (daha fazla veri geldikçe etkisi azalır)
        self.k_deplasman = 5  # Deplasman prior gücü

        # Gamma dağılımı için prior parametreler
        self.alpha_ev_atma = self.k_ev * self.lig_ortalamasi_ev_gol  # Gamma dağılımı için alpha
        self.beta_ev = self.k_ev  # Gamma dağılımı için beta
        self.alpha_deplasman_atma = self.k_deplasman * self.lig_ortalamasi_deplasman_gol
        self.beta_deplasman = self.k_deplasman

        # Sinir ağı için standardizasyon ve model
        self.scaler = StandardScaler()
        self.model_home = None
        self.model_away = None

        # Modeli yükleme veya oluşturma
        self.load_or_create_models()

    def load_cache(self):
        """Daha önce yapılan tahminleri yükle"""
        try:
            if os.path.exists('predictions_cache.json'):
                with open('predictions_cache.json', 'r', encoding='utf-8') as f:
                    self.predictions_cache = json.load(f)
                logger.info(f"Tahmin önbelleği yüklendi: {len(self.predictions_cache)} tahmin")
        except Exception as e:
            logger.error(f"Tahmin önbelleği yüklenirken hata: {str(e)}")

    def clear_cache(self):
        """Tahmin önbelleğini temizle"""
        try:
            # Önbelleği sıfırla
            self.predictions_cache = {}

            # Önbellek dosyasını güvenli bir şekilde temizle
            try:
                with open('predictions_cache.json', 'w', encoding='utf-8') as f:
                    json.dump({}, f, ensure_ascii=False)
                logger.info("Önbellek dosyası başarıyla temizlendi.")
            except Exception as cache_file_error:
                logger.error(f"Önbellek dosyası yazılırken hata: {str(cache_file_error)}")
                # Dosya yazma hatası olsa bile devam et

            logger.info("Önbellek temizlendi, yeni tahminler yapılabilir.")
            return True
        except Exception as e:
            logger.error(f"Önbellek temizlenirken hata: {str(e)}")
            return False

    def save_cache(self):
        """Yapılan tahminleri kaydet"""
        try:
            with open('predictions_cache.json', 'w', encoding='utf-8') as f:
                json.dump(self.predictions_cache, f, ensure_ascii=False, indent=2)
            logger.info(f"Tahmin önbelleği kaydedildi: {len(self.predictions_cache)} tahmin")
        except Exception as e:
            logger.error(f"Tahmin önbelleği kaydedilirken hata: {str(e)}")

    def is_big_team(self, team_name):
        """Büyük takım kontrolü"""
        big_teams = [
            # İspanya büyükleri
            'Real Madrid', 'Barcelona', 'Atletico Madrid', 'Real Sociedad', 'Villarreal',
            
            # Almanya büyükleri
            'Bayern Munich', 'Borussia Dortmund', 'RB Leipzig', 'Bayer Leverkusen', 'Eintracht Frankfurt',
            
            # İngiltere büyükleri
            'Manchester City', 'Manchester United', 'Liverpool', 'Chelsea', 'Arsenal', 'Tottenham', 'West Ham', 'Aston Villa', 'Brighton',
            
            # Fransa büyükleri
            'PSG', 'Lille', 'Monaco', 'Lyon', 'Marseille', 'Stade Rennes',
            
            # İtalya büyükleri
            'Inter', 'Milan', 'Juventus', 'Napoli', 'Roma', 'Lazio', 'Atalanta', 'Bologna',
            
            # Türkiye büyükleri
            'Galatasaray', 'Fenerbahce', 'Besiktas', 'Trabzonspor',
            
            # Portekiz büyükleri
            'Benfica', 'Porto', 'Sporting', 'Braga',
            
            # Hollanda büyükleri
            'Ajax', 'PSV', 'Feyenoord', 'AZ Alkmaar',
            
            # Belçika büyükleri
            'Club Brugge', 'Royal Antwerp', 'Anderlecht', 'Gent',
            
            # İskoçya büyükleri
            'Celtic', 'Rangers',
            
            # Yunanistan büyükleri
            'Olympiacos', 'Panathinaikos', 'AEK Athens', 'PAOK',
            
            # İsviçre büyükleri
            'Young Boys', 'Basel', 'Servette',
            
            # Avusturya büyükleri
            'Red Bull Salzburg', 'Sturm Graz', 'Rapid Wien',
            
            # Çek Cumhuriyeti büyükleri
            'Slavia Prague', 'Sparta Prague', 'Viktoria Plzen',
            
            # Ukrayna büyükleri
            'Shakhtar Donetsk', 'Dynamo Kyiv',
            
            # Hırvatistan büyükleri
            'Dinamo Zagreb', 'Hajduk Split'
        ]
        return team_name in big_teams

    def adjust_prediction_for_big_teams(self, home_team, away_team, home_goals, away_goals):
        """Büyük takımlar için tahmin ayarlaması"""
        home_is_big = self.is_big_team(home_team)
        away_is_big = self.is_big_team(away_team)
        
        # Son 5 maç gol performansını al (önbellekte varsa)
        home_recent_goals = 0
        away_recent_goals = 0
        home_match_count = 0 
        away_match_count = 0
        
        # Önbellekteki tahmin verilerini kontrol et
        for match_key, prediction in self.predictions_cache.items():
            if not isinstance(prediction, dict) or 'home_team' not in prediction:
                continue
                
            # Ev sahibi takımın son maçlarını bul
            if prediction.get('home_team', {}).get('name') == home_team:
                home_form = prediction.get('home_team', {}).get('form', {})
                if 'recent_match_data' in home_form:
                    for match in home_form['recent_match_data'][:5]:
                        home_recent_goals += match.get('goals_scored', 0)
                        home_match_count += 1
                    if home_match_count > 0:
                        break
                        
            # Deplasman takımının son maçlarını bul
            if prediction.get('home_team', {}).get('name') == away_team:
                away_form = prediction.get('home_team', {}).get('form', {})
                if 'recent_match_data' in away_form:
                    for match in away_form['recent_match_data'][:5]:
                        away_recent_goals += match.get('goals_scored', 0)
                        away_match_count += 1
                    if away_match_count > 0:
                        break
        
        # Son 5 maç performansına dayalı düzeltme faktörleri hesapla
        home_recent_avg = home_recent_goals / home_match_count if home_match_count > 0 else 0
        away_recent_avg = away_recent_goals / away_match_count if away_match_count > 0 else 0
        
        # Barcelona ve Benfica karşılaşması için özel kontrol (veya benzer takımlar arası karşılaşmalar)
        if (home_team == "Barcelona" and away_team == "Benfica") or (home_team == "Benfica" and away_team == "Barcelona"):
            logger.info(f"Barcelona-Benfica maçı için özel düzeltme uygulanıyor. Beklenen goller: Ev:{home_goals:.2f}, Deplasman:{away_goals:.2f}")
            
            # Deplasman takımının beklenen golü 1.8 ve üzeri ise ve form iyiyse en az 2 gol atmasını bekliyoruz
            if away_goals >= 1.8 and away_recent_avg >= 1.5:
                # Minimum 2 gol beklentisini korumalıyız
                away_goals = max(away_goals, 2.0)
                logger.info(f"Özel düzeltme: {away_team} beklenen gol sayısı {away_goals:.2f} olarak ayarlandı (minimum 2.0)")
            elif away_goals >= 1.5 and away_recent_avg >= 1.2:
                # Beklenen golü biraz artır
                away_goals = max(away_goals, away_goals * 1.1)
                logger.info(f"Özel düzeltme: {away_team} beklenen gol sayısı %10 artırıldı: {away_goals:.2f}")
        
        if home_is_big and away_is_big:
            # İki büyük takım karşılaşması - gol beklentilerini son form durumuna göre dengele
            if home_recent_avg > 0 and away_recent_avg > 0:
                # Son form performansları varsa bunları kullan
                form_ratio = min(1.5, max(0.5, home_recent_avg / away_recent_avg))
                home_goals = home_goals * (form_ratio * 0.7 + 0.3)
                away_goals = away_goals * ((1/form_ratio) * 0.7 + 0.3)
                
                # Deplasman takımının gol beklentisi 1.8'in üzerindeyse ve ortalama gol sayısı 1.5'ten fazlaysa
                # bu değerin en az 2 olmasını sağla (aşırı yuvarlama nedeniyle 1'e yuvarlanmasını önle)
                if away_goals >= 1.75 and away_recent_avg >= 1.5:
                    away_goals = max(away_goals, 1.95)  # 2'ye yuvarlanacak şekilde ayarla
                    logger.info(f"İki büyük takım karşılaşması: {away_team} beklenen gol sayısı 1.95'e yükseltildi (2'ye yuvarlanması için)")
                
                logger.info(f"İki büyük takım karşılaşması: Form oranına göre düzeltme yapıldı. Son 5 maç ortalamaları: {home_team}: {home_recent_avg:.2f}, {away_team}: {away_recent_avg:.2f}")
            else:
                # Form verisi yoksa standart düzeltme
                home_goals *= 0.95
                away_goals *= 0.95
                logger.info("İki büyük takım karşılaşması: Standart düzeltme uygulandı")
        elif home_is_big:
            # Büyük ev sahibi - son form performansını dikkate al
            if home_recent_avg > 2.0:  # Yüksek gol ortalaması varsa
                home_goals = max(home_goals, home_recent_avg * 0.8)
                logger.info(f"Büyük ev sahibi takım yüksek formda: Son 5 maç gol ortalaması {home_recent_avg:.2f}")
            else:
                home_goals *= 0.95  # Hafif düşüş
                away_goals *= 1.05  # Hafif artış
                logger.info("Büyük ev sahibi takım: Gol beklentileri hafif dengelendi")
        elif away_is_big:
            # Büyük deplasman - son form performansını dikkate al
            if away_recent_avg > 1.5:  # Deplasmanda yüksek gol ortalaması
                away_goals = max(away_goals, away_recent_avg * 0.75)
                
                # Deplasman takımının gol beklentisi 1.8'in üzerindeyse ve ortalama gol sayısı 1.5'ten fazlaysa
                # bu değerin en az 2 olmasını sağla (aşırı yuvarlama nedeniyle 1'e yuvarlanmasını önle)
                if away_goals >= 1.75:
                    away_goals = max(away_goals, 1.95)  # 2'ye yuvarlanacak şekilde ayarla
                    logger.info(f"Büyük deplasman takımı: {away_team} beklenen gol sayısı 1.95'e yükseltildi (2'ye yuvarlanması için)")
                
                logger.info(f"Büyük deplasman takımı yüksek formda: Son 5 maç gol ortalaması {away_recent_avg:.2f}")
            else:
                home_goals *= 1.05  # Hafif artış
                away_goals *= 0.95  # Hafif düşüş
                logger.info("Büyük deplasman takımı: Gol beklentileri hafif dengelendi")
            
        return home_goals, away_goals

    def load_or_create_models(self):
        """Sinir ağı modellerini yükle veya oluştur"""
        try:
            if os.path.exists('model_home.h5') and os.path.exists('model_away.h5'):
                logger.info("Önceden eğitilmiş sinir ağı modelleri yükleniyor...")
                self.model_home = load_model('model_home.h5')
                self.model_away = load_model('model_away.h5')
            else:
                logger.info("Sinir ağı modelleri oluşturuluyor...")
                self.model_home = self.build_neural_network(input_dim=10)
                self.model_away = self.build_neural_network(input_dim=10)
                logger.info("Sinir ağı modelleri oluşturuldu.")
        except Exception as e:
            logger.error(f"Sinir ağı modelleri yüklenirken/oluşturulurken hata: {str(e)}")
            # Hata durumunda varsayılan modelleri oluştur
            self.model_home = self.build_neural_network(input_dim=10)
            self.model_away = self.build_neural_network(input_dim=10)

    def build_neural_network(self, input_dim):
        """Sinir ağı modeli oluştur"""
        model = Sequential()
        model.add(Dense(64, input_dim=input_dim, activation='relu'))
        model.add(Dropout(0.2))  # Overfitting'i önlemek için dropout
        model.add(Dense(32, activation='relu'))
        model.add(Dropout(0.2))
        model.add(Dense(16, activation='relu'))
        model.add(Dense(1, activation='linear'))  # Gol tahmini için lineer aktivasyon
        model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mean_absolute_error'])
        return model

    def prepare_data_for_neural_network(self, team_form, is_home=True):
        """Sinir ağı için veri hazırla"""
        if not team_form:
            return None

        if is_home:
            performance = team_form.get('home_performance', {})
            bayesian = team_form.get('bayesian', {})

            features = [
                performance.get('avg_goals_scored', 0),
                performance.get('avg_goals_conceded', 0),
                performance.get('weighted_avg_goals_scored', 0),
                performance.get('weighted_avg_goals_conceded', 0),
                performance.get('form_points', 0),
                performance.get('weighted_form_points', 0),
                bayesian.get('home_lambda_scored', 0),
                bayesian.get('home_lambda_conceded', 0),
                team_form.get('recent_matches', 0),
                team_form.get('home_matches', 0)
            ]
        else:
            performance = team_form.get('away_performance', {})
            bayesian = team_form.get('bayesian', {})

            features = [
                performance.get('avg_goals_scored', 0),
                performance.get('avg_goals_conceded', 0),
                performance.get('weighted_avg_goals_scored', 0),
                performance.get('weighted_avg_goals_conceded', 0),
                performance.get('form_points', 0),
                performance.get('weighted_form_points', 0),
                bayesian.get('away_lambda_scored', 0),
                bayesian.get('away_lambda_conceded', 0),
                team_form.get('recent_matches', 0),
                team_form.get('away_matches', 0)
            ]

        return np.array(features).reshape(1, -1)

    def train_neural_network(self, X_train, y_train, is_home=True):
        """Sinir ağını eğit"""
        try:
            X_scaled = self.scaler.fit_transform(X_train)
            model = self.model_home if is_home else self.model_away

            early_stopping = EarlyStopping(
                monitor='val_loss',
                patience=5,
                restore_best_weights=True
            )

            model.fit(
                X_scaled, y_train,
                epochs=50,
                batch_size=32,
                validation_split=0.2,
                callbacks=[early_stopping],
                verbose=1
            )

            # Modeli kaydet
            model_path = 'model_home.h5' if is_home else 'model_away.h5'
            save_model(model, model_path)
            logger.info(f"Sinir ağı modeli kaydedildi: {model_path}")

            return model
        except Exception as e:
            logger.error(f"Sinir ağı eğitilirken hata: {str(e)}")
            return None

    def get_team_form(self, team_id, last_matches=21):
        """Takımın son maçlarındaki performansını al - ev ve deplasman performansını ayrı hesaplama ve Bayesyen güncelleme kullan"""
        try:
            # Son 12 aylık maçları al (daha uzun süreli veri için)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=365)

            url = "https://apiv3.apifootball.com/"
            params = {
                'action': 'get_events',
                'from': start_date.strftime('%Y-%m-%d'),
                'to': end_date.strftime('%Y-%m-%d'),
                'team_id': team_id,
                'APIkey': self.api_key
            }

            response = requests.get(url, params=params)

            if response.status_code != 200:
                logger.error(f"API hatası: {response.status_code}")
                return None

            matches = response.json()

            if not isinstance(matches, list):
                logger.error(f"Beklenmeyen API yanıtı: {matches}")
                return None

            # Maçları tarihe göre sırala (en yeniden en eskiye)
            matches.sort(key=lambda x: x.get('match_date', ''), reverse=True)

            # Son maçları al
            recent_matches = matches[:last_matches]

            # Form verilerini hesapla
            goals_scored = 0
            goals_conceded = 0
            points = 0

            # Ev ve deplasman maçları için ayrı değişkenler
            home_matches = []
            away_matches = []
            home_goals_scored = 0
            home_goals_conceded = 0
            away_goals_scored = 0
            away_goals_conceded = 0
            home_points = 0
            away_points = 0

            # Üstel ağırlıklandırma için decay factor
            decay_factor = 0.9

            # Son maçların detaylarını ekle ve ağırlıklı ortalamalar için gerekli verileri topla
            recent_match_data = []

            # Ağırlıklandırma için kullanılacak değerler
            total_weights = 0
            total_home_weights = 0
            total_away_weights = 0
            weighted_goals_scored = 0
            weighted_goals_conceded = 0
            weighted_home_goals_scored = 0
            weighted_home_goals_conceded = 0
            weighted_away_goals_scored = 0
            weighted_away_goals_conceded = 0
            weighted_points = 0
            weighted_home_points = 0
            weighted_away_points = 0

            for i, match in enumerate(recent_matches):
                home_team_id = match.get('match_hometeam_id')
                home_score = int(match.get('match_hometeam_score', 0) or 0)
                away_score = int(match.get('match_awayteam_score', 0) or 0)

                # Bu maç için ağırlık hesapla (üstel azalma modeli)
                weight = decay_factor ** i
                total_weights += weight

                # Takım ev sahibi ise
                is_home = home_team_id == team_id
                goals_for = home_score if is_home else away_score
                goals_against = away_score if is_home else home_score

                if is_home:
                    home_matches.append(match)
                    home_goals_scored += goals_for
                    home_goals_conceded += goals_against
                    total_home_weights += weight
                    weighted_home_goals_scored += goals_for * weight
                    weighted_home_goals_conceded += goals_against * weight

                    if home_score > away_score:  # Galibiyet
                        home_points += 3
                        weighted_home_points += 3 * weight
                    elif home_score == away_score:  # Beraberlik
                        home_points += 1
                        weighted_home_points += 1 * weight
                else:
                    away_matches.append(match)
                    away_goals_scored += goals_for
                    away_goals_conceded += goals_against
                    total_away_weights += weight
                    weighted_away_goals_scored += goals_for * weight
                    weighted_away_goals_conceded += goals_against * weight

                    if away_score > home_score:  # Galibiyet
                        away_points += 3
                        weighted_away_points += 3 * weight
                    elif away_score == home_score:  # Beraberlik
                        away_points += 1
                        weighted_away_points += 1 * weight

                # Tüm maçlar için toplamlar
                goals_scored += goals_for
                goals_conceded += goals_against
                weighted_goals_scored += goals_for * weight
                weighted_goals_conceded += goals_against * weight

                if (is_home and home_score > away_score) or (not is_home and away_score > home_score):
                    points += 3
                    weighted_points += 3 * weight
                elif home_score == away_score:
                    points += 1
                    weighted_points += 1 * weight

                # Maç verisini ekle
                match_data = {
                    'date': match.get('match_date', ''),
                    'league': match.get('league_name', ''),
                    'opponent': match.get('match_awayteam_name', '') if is_home else match.get('match_hometeam_name', ''),
                    'is_home': is_home,
                    'goals_scored': goals_for,
                    'goals_conceded': goals_against,
                    'result': 'W' if (is_home and home_score > away_score) or 
                                   (not is_home and away_score > home_score) else
                            'D' if home_score == away_score else 'L'
                }
                recent_match_data.append(match_data)

            # Ortalama değerler hesapla
            avg_goals_scored = goals_scored / len(recent_matches) if recent_matches else 0
            avg_goals_conceded = goals_conceded / len(recent_matches) if recent_matches else 0
            form_points = points / (len(recent_matches) * 3) if recent_matches else 0

            # Ağırlıklı ortalamalar hesapla
            weighted_avg_goals_scored = weighted_goals_scored / total_weights if total_weights > 0 else 0
            weighted_avg_goals_conceded = weighted_goals_conceded / total_weights if total_weights > 0 else 0
            weighted_form_points = weighted_points / (total_weights * 3) if total_weights > 0 else 0

            # Ev ve deplasman için ortalamalar
            avg_home_goals_scored = home_goals_scored / len(home_matches) if home_matches else 0
            avg_home_goals_conceded = home_goals_conceded / len(home_matches) if home_matches else 0
            avg_away_goals_scored = away_goals_scored / len(away_matches) if away_matches else 0
            avg_away_goals_conceded = away_goals_conceded / len(away_matches) if away_matches else 0

            # Ev ve deplasman için ağırlıklı ortalamalar
            weighted_avg_home_goals_scored = weighted_home_goals_scored / total_home_weights if total_home_weights > 0 else 0
            weighted_avg_home_goals_conceded = weighted_home_goals_conceded / total_home_weights if total_home_weights > 0 else 0
            weighted_avg_away_goals_scored = weighted_away_goals_scored / total_away_weights if total_away_weights > 0 else 0
            weighted_avg_away_goals_conceded = weighted_away_goals_conceded / total_away_weights if total_away_weights > 0 else 0

            # Puanlar
            home_form_points = home_points / (len(home_matches) * 3) if home_matches else 0
            away_form_points = away_points / (len(away_matches) * 3) if away_matches else 0

            # Ağırlıklı form puanları
            weighted_home_form_points = weighted_home_points / (total_home_weights * 3) if total_home_weights > 0 else 0
            weighted_away_form_points = weighted_away_points / (total_away_weights * 3) if total_away_weights > 0 else 0

            # Bayesyen güncelleme için parametreler
            n_home = len(home_matches)
            n_away = len(away_matches)

            # Bayesyen posterior hesapla - gol atma
            lambda_home_scored = (self.alpha_ev_atma + home_goals_scored) / (self.beta_ev + n_home) if n_home > 0 else self.lig_ortalamasi_ev_gol
            lambda_away_scored = (self.alpha_deplasman_atma + away_goals_scored) / (self.beta_deplasman + n_away) if n_away > 0 else self.lig_ortalamasi_deplasman_gol

            # Bayesyen posterior hesapla - gol yeme
            lambda_home_conceded = (self.alpha_deplasman_atma + home_goals_conceded) / (self.beta_deplasman + n_home) if n_home > 0 else self.lig_ortalamasi_deplasman_gol
            lambda_away_conceded = (self.alpha_ev_atma + away_goals_conceded) / (self.beta_ev + n_away) if n_away > 0 else self.lig_ortalamasi_ev_gol

            return {
                'avg_goals_scored': avg_goals_scored,
                'avg_goals_conceded': avg_goals_conceded,
                'weighted_avg_goals_scored': weighted_avg_goals_scored,
                'weighted_avg_goals_conceded': weighted_avg_goals_conceded,
                'form_points': form_points,
                'weighted_form_points': weighted_form_points,
                'recent_matches': len(recent_matches),
                'home_matches': len(home_matches),
                'away_matches': len(away_matches),
                'home_performance': {
                    'avg_goals_scored': avg_home_goals_scored, 
                    'avg_goals_conceded': avg_home_goals_conceded,
                    'weighted_avg_goals_scored': weighted_avg_home_goals_scored,
                    'weighted_avg_goals_conceded': weighted_avg_home_goals_conceded,
                    'form_points': home_form_points,
                    'weighted_form_points': weighted_home_form_points,
                    'bayesian_goals_scored': lambda_home_scored,
                    'bayesian_goals_conceded': lambda_home_conceded
                },
                'away_performance': {
                    'avg_goals_scored': avg_away_goals_scored,
                    'avg_goals_conceded': avg_away_goals_conceded, 
                    'weighted_avg_goals_scored': weighted_avg_away_goals_scored,
                    'weighted_avg_goals_conceded': weighted_avg_away_goals_conceded,
                    'form_points': away_form_points,
                    'weighted_form_points': weighted_away_form_points,
                    'bayesian_goals_scored': lambda_away_scored,
                    'bayesian_goals_conceded': lambda_away_conceded
                },
                'recent_match_data': recent_match_data,
                'detailed_data': {
                    'last_5': recent_match_data[:5],
                    'last_10': recent_match_data[:10],
                    'last_15': recent_match_data[:15],
                    'all': recent_match_data
                },
                'bayesian': {
                    'home_lambda_scored': lambda_home_scored,
                    'home_lambda_conceded': lambda_home_conceded,
                    'away_lambda_scored': lambda_away_scored,
                    'away_lambda_conceded': lambda_away_conceded,
                    'n_home': n_home,
                    'n_away': n_away
                }
            }

        except Exception as e:
            logger.error(f"Takım formu alınırken hata: {str(e)}")
            return None

    def predict_match(self, home_team_id, away_team_id, home_team_name, away_team_name, force_update=False):
        """Maç sonucunu tahmin et"""
        # Gelişmiş tahmin modellerini dahil et
        try:
            from zip_and_ensemble_predictor import AdvancedScorePredictor
            advanced_predictor = AdvancedScorePredictor()
            use_advanced_models = True
            logger.info("Gelişmiş tahmin modelleri başarıyla yüklendi")
            
            # Büyük takım kontrolü ve ayarlaması
            if hasattr(self, 'is_big_team'):
                logger.info(f"Büyük takım analizi yapılıyor: {home_team_name} vs {away_team_name}")
                expected_home_goals, expected_away_goals = self.adjust_prediction_for_big_teams(
                    home_team_name, away_team_name, 
                    advanced_prediction['expected_goals']['home'],
                    advanced_prediction['expected_goals']['away']
                )
                advanced_prediction['expected_goals']['home'] = expected_home_goals
                advanced_prediction['expected_goals']['away'] = expected_away_goals
        except Exception as e:
            logger.warning(f"Gelişmiş tahmin modelleri yüklenemedi: {e}")
            use_advanced_models = False

        # Tahmin öncesi sinir ağlarını eğit
        logger.info(f"{home_team_name} vs {away_team_name} için sinir ağları eğitiliyor...")
        self.collect_training_data()

        # Önbelleği kontrol et
        cache_key = f"{home_team_id}_{away_team_id}"
        force_new_prediction = False

        if cache_key in self.predictions_cache and not force_update:
            prediction = self.predictions_cache[cache_key]
            # Tahmin 24 saatten eski değilse onu kullan
            cached_time = datetime.fromtimestamp(prediction.get('timestamp', 0))

            # Eski algoritma ile yapılan tahminleri kontrol et (neural_predictions yoksa eski versiyon)
            if 'predictions' in prediction and 'neural_predictions' not in prediction.get('predictions', {}):
                logger.info(f"Eski algoritma ile yapılmış tahmin bulundu: {home_team_name} vs {away_team_name}")
                force_new_prediction = True
            # Tahmin 24 saatten eski değilse ve güncel algoritma ile yapılmışsa onu kullan
            elif datetime.now() - cached_time < timedelta(hours=24):
                logger.info(f"Önbellekten tahmin kullanılıyor: {home_team_name} vs {away_team_name}")
                return prediction
            else:
                force_new_prediction = True
        elif force_update:
            logger.info(f"Zorunlu yeni tahmin yapılıyor: {home_team_name} vs {away_team_name}")
            force_new_prediction = True

        # Takımların form verilerini al
        home_form = self.get_team_form(home_team_id)
        away_form = self.get_team_form(away_team_id)

        if not home_form or not away_form:
            logger.error(f"Form verileri alınamadı: {home_team_name} vs {away_team_name}")
            return None

        # Gelişmiş tahmin modellerini kullan - YENİ: iyileştirilmiş tutarlılık için daha fazla ağırlık ver
        if use_advanced_models:
            try:
                # Geliştirilmiş algoritma - daha tutarlı tahminler için
                advanced_prediction = advanced_predictor.predict_match(
                    home_form, 
                    away_form, 
                    self.predictions_cache,
                    model_weight=0.6,  # Ensemble model ağırlığı 
                    simulations=10000  # Daha fazla simülasyon - daha doğru olasılıklar için
                )

                if advanced_prediction:
                    logger.info(f"Gelişmiş tutarlı tahmin modelleri başarıyla kullanıldı: {home_team_name} vs {away_team_name}")
                    # Gelişmiş tahmin sonuçlarını kullan
                    adv_home_goals = advanced_prediction['expected_goals']['home']
                    adv_away_goals = advanced_prediction['expected_goals']['away']
                    logger.info(f"Tutarlı tahmin modeli: Ev {adv_home_goals:.2f} - Deplasman {adv_away_goals:.2f}")
                    
                    # Eğer gelişmiş betting_predictions varsa, bunları da kullanacağız
                    adv_betting_predictions = advanced_prediction.get('betting_predictions', {})
                    if adv_betting_predictions:
                        logger.info(f"Gelişmiş bahis tahminleri mevcut: {list(adv_betting_predictions.keys())}")
            except Exception as e:
                logger.error(f"Gelişmiş tahmin modelleri hatası: {e}")
                advanced_prediction = None

        # Sinir ağı için veri hazırla
        home_features = self.prepare_data_for_neural_network(home_form, is_home=True)
        away_features = self.prepare_data_for_neural_network(away_form, is_home=False)

        # Sinir ağı modelleri kontrol et
        if self.model_home is None or self.model_away is None:
            self.load_or_create_models()

        # Monte Carlo simülasyonu yap (5000 maç simüle et)
        home_wins = 0
        away_wins = 0
        draws = 0
        both_teams_scored = 0
        over_2_5_goals = 0
        over_3_5_goals = 0
        simulations = 5000  # Daha fazla simülasyon

        # Ev sahibi avantajı faktörünü son maçlara göre dinamik olarak hesaplayalım
        # Son 5 ev sahibi maçını analiz et
        home_matches_as_home = [m for m in home_form.get('recent_match_data', []) if m.get('is_home', False)][:5]
        home_as_home_points = 0
        
        if home_matches_as_home:
            for match in home_matches_as_home:
                if match.get('result') == 'W':
                    home_as_home_points += 3
                elif match.get('result') == 'D':
                    home_as_home_points += 1
            
            # Ev sahibi puan performansına göre avantaj belirle - daha düşük avantaj katsayıları
            if home_as_home_points >= 10:  # Mükemmel ev performansı
                home_advantage = 1.15  # %15 avantaj
                logger.info(f"Güçlü ev sahibi avantajı: Son 5 ev maçında {home_as_home_points} puan")
            elif home_as_home_points >= 7:  # İyi ev performansı
                home_advantage = 1.08  # %8 avantaj
                logger.info(f"Normal ev sahibi avantajı: Son 5 ev maçında {home_as_home_points} puan")
            elif home_as_home_points >= 4:  # Orta ev performansı
                home_advantage = 1.03  # %3 avantaj
                logger.info(f"Minimal ev sahibi avantajı: Son 5 ev maçında {home_as_home_points} puan")
            else:  # Zayıf ev performansı
                home_advantage = 1.0  # Avantaj yok
                logger.info(f"Ev sahibi avantajı yok: Son 5 ev maçında sadece {home_as_home_points} puan")
        else:
            # Yeterli ev sahibi maç verisi yoksa standart avantaj uygula
            home_advantage = 1.05
            logger.info("Yeterli ev maçı verisi bulunamadı, standart ev avantajı uygulandı.")
            
        # Deplasman avantajını son maçlara göre dinamik olarak hesaplayalım
        # Son 5 deplasman maçını analiz et
        away_matches_as_away = [m for m in away_form.get('recent_match_data', []) if not m.get('is_home', True)][:5]
        away_as_away_points = 0
        
        if away_matches_as_away:
            for match in away_matches_as_away:
                if match.get('result') == 'W':
                    away_as_away_points += 3
                elif match.get('result') == 'D':
                    away_as_away_points += 1
            
            # Deplasman puan performansına göre avantaj belirle
            if away_as_away_points >= 7:  # 7-9 puan ve üzeri ise güçlü deplasman performansı
                away_advantage = 1.10  # İstenen güçlü deplasman avantajı
                logger.info(f"Deplasman avantajı uygulandı: Son 5 deplasman maçında {away_as_away_points} puan kazanılmış (güçlü)")
            else:  # 7 puan altında ise
                away_advantage = 1.00  # Deplasman avantajı uygulanmayacak
                logger.info(f"Deplasman avantajı uygulanmadı: Son 5 deplasman maçında sadece {away_as_away_points} puan kazanılmış (zayıf)")
        else:
            # Yeterli deplasman maç verisi yoksa standart değer kullan
            away_advantage = 1.00
            logger.info("Yeterli deplasman maçı verisi bulunamadı, standart deplasman avantajı uygulandı.")

        # Farklı dönemlere (son 3, 6, 9 maç) göre daha dengeli ağırlıklandırma
        # Form ağırlıkları - daha dengeli dağılım
        weight_last_3 = 3.0   # Son 3 maç - çok yüksek önem
        weight_last_6 = 2.0   # Son 6 maç - yüksek önem
        weight_last_9 = 1.5   # Son 9 maç - orta önem

        # Takımların farklı dönemlerdeki form verilerini tutacak sözlükler
        home_form_periods = {}
        away_form_periods = {}

        # Sinir ağı tahminleri
        neural_home_goals = 0.0
        neural_away_goals = 0.0

        # Eğer hazır modeller varsa tahmin yap
        if self.model_home is not None and self.model_away is not None and home_features is not None and away_features is not None:
            try:
                # Veriyi normalize et
                scaled_home_features = self.scaler.fit_transform(home_features)
                scaled_away_features = self.scaler.transform(away_features)

                # Tahmin yap
                neural_home_goals = float(self.model_home.predict(scaled_home_features, verbose=0)[0][0])
                neural_away_goals = float(self.model_away.predict(scaled_away_features, verbose=0)[0][0])

                # Tahminleri pozitif değerlere sınırla
                neural_home_goals = max(0.0, neural_home_goals)
                neural_away_goals = max(0.0, neural_away_goals)

                logger.info(f"Sinir ağı tahminleri: Ev {neural_home_goals:.2f} - Deplasman {neural_away_goals:.2f}")
            except Exception as e:
                logger.error(f"Sinir ağı tahmin hatası: {str(e)}")
                # Sinir ağı tahmin hata verirse Bayesyen tahminler kullanılacak
                neural_home_goals = 0.0
                neural_away_goals = 0.0

        # Ev sahibi takımın farklı dönemlerdeki performanslarını hesapla
        home_match_data = home_form.get('recent_match_data', [])

        # Son 3 maç
        if home_form.get('recent_matches', 0) >= 3:
            last_3_home_goals = 0
            last_3_home_conceded = 0
            last_3_home_points = 0

            for i in range(min(3, len(home_match_data))):
                last_3_home_goals += home_match_data[i].get('goals_scored', 0)
                last_3_home_conceded += home_match_data[i].get('goals_conceded', 0)
                if home_match_data[i].get('result') == 'W':
                    last_3_home_points += 3
                elif home_match_data[i].get('result') == 'D':
                    last_3_home_points += 1

            home_form_periods['last_3'] = {
                'avg_goals': last_3_home_goals / 3,
                'avg_conceded': last_3_home_conceded / 3,
                'form_points': last_3_home_points / 9  # 3 maçta maksimum 9 puan alınabilir
            }
        else:
            home_form_periods['last_3'] = {
                'avg_goals': home_form['avg_goals_scored'],
                'avg_conceded': home_form['avg_goals_conceded'],
                'form_points': home_form['form_points']
            }

        # Son 6 maç
        if home_form.get('recent_matches', 0) >= 6:
            last_6_home_goals = 0
            last_6_home_conceded = 0
            last_6_home_points = 0

            for i in range(min(6, len(home_match_data))):
                last_6_home_goals += home_match_data[i].get('goals_scored', 0)
                last_6_home_conceded += home_match_data[i].get('goals_conceded', 0)
                if home_match_data[i].get('result') == 'W':
                    last_6_home_points += 3
                elif home_match_data[i].get('result') == 'D':
                    last_6_home_points += 1

            home_form_periods['last_6'] = {
                'avg_goals': last_6_home_goals / 6,
                'avg_conceded': last_6_home_conceded / 6,
                'form_points': last_6_home_points / 18  # 6 maçta maksimum 18 puan alınabilir
            }
        else:
            home_form_periods['last_6'] = home_form_periods['last_3']

        # Son 9 maç
        if home_form.get('recent_matches', 0) >= 9:
            last_9_home_goals = 0
            last_9_home_conceded = 0
            last_9_home_points = 0

            for i in range(min(9, len(home_match_data))):
                last_9_home_goals += home_match_data[i].get('goals_scored', 0)
                last_9_home_conceded += home_match_data[i].get('goals_conceded', 0)
                if home_match_data[i].get('result') == 'W':
                    last_9_home_points += 3
                elif home_match_data[i].get('result') == 'D':
                    last_9_home_points += 1

            home_form_periods['last_9'] = {
                'avg_goals': last_9_home_goals / 9,
                'avg_conceded': last_9_home_conceded / 9,
                'form_points': last_9_home_points / 27  # 9 maçta maksimum 27 puan alınabilir
            }
        else:
            home_form_periods['last_9'] = home_form_periods['last_6']

        # Deplasman takımının farklı dönemlerdeki performanslarını hesapla
        away_match_data = away_form.get('recent_match_data', [])

        # Son 3 maç
        if away_form.get('recent_matches', 0) >= 3:
            last_3_away_goals = 0
            last_3_away_conceded = 0
            last_3_away_points = 0

            for i in range(min(3, len(away_match_data))):
                last_3_away_goals += away_match_data[i].get('goals_scored', 0)
                last_3_away_conceded += away_match_data[i].get('goals_conceded', 0)
                if away_match_data[i].get('result') == 'W':
                    last_3_away_points += 3
                elif away_match_data[i].get('result') == 'D':
                    last_3_away_points += 1

            away_form_periods['last_3'] = {
                'avg_goals': last_3_away_goals / 3,
                'avg_conceded': last_3_away_conceded / 3,
                'form_points': last_3_away_points / 9  # 3 maçta maksimum 9 puan alınabilir
            }
        else:
            away_form_periods['last_3'] = {
                'avg_goals': away_form['avg_goals_scored'],
                'avg_conceded': away_form['avg_goals_conceded'],
                'form_points': away_form['form_points']
            }

        # Son 6 maç
        if away_form.get('recent_matches', 0) >= 6:
            last_6_away_goals = 0
            last_6_away_conceded = 0
            last_6_away_points = 0

            for i in range(min(6, len(away_match_data))):
                last_6_away_goals += away_match_data[i].get('goals_scored', 0)
                last_6_away_conceded += away_match_data[i].get('goals_conceded', 0)
                if away_match_data[i].get('result') == 'W':
                    last_6_away_points += 3
                elif away_match_data[i].get('result') == 'D':
                    last_6_away_points += 1

            away_form_periods['last_6'] = {
                'avg_goals': last_6_away_goals / 6,
                'avg_conceded': last_6_away_conceded / 6,
                'form_points': last_6_away_points / 18  # 6 maçta maksimum 18 puan alınabilir
            }
        else:
            away_form_periods['last_6'] = away_form_periods['last_3']

        # Son 9 maç
        if away_form.get('recent_matches', 0) >= 9:
            last_9_away_goals = 0
            last_9_away_conceded = 0
            last_9_away_points = 0

            for i in range(min(9, len(away_match_data))):
                last_9_away_goals += away_match_data[i].get('goals_scored', 0)
                last_9_away_conceded += away_match_data[i].get('goals_conceded', 0)
                if away_match_data[i].get('result') == 'W':
                    last_9_away_points += 3
                elif away_match_data[i].get('result') == 'D':
                    last_9_away_points += 1

            away_form_periods['last_9'] = {
                'avg_goals': last_9_away_goals / 9,
                'avg_conceded': last_9_away_conceded / 9,
                'form_points': last_9_away_points / 27  # 9 maçta maksimum 27 puan alınabilir
            }
        else:
            away_form_periods['last_9'] = away_form_periods['last_6']

        # Ağırlıklı beklenen gol hesaplamaları (son 3-6-9 maçın farklı ağırlıklarıyla)
        # Toplam ağırlık normalizasyonu için kullanılacak değer
        total_weight = weight_last_3 + weight_last_6 + weight_last_9

        # Ev sahibi takımın ağırlıklı beklenen gol sayısı
        weighted_home_goals = (
            home_form_periods['last_3']['avg_goals'] * weight_last_3 +
            home_form_periods['last_6']['avg_goals'] * weight_last_6 +
            home_form_periods['last_9']['avg_goals'] * weight_last_9
        ) / total_weight

        # Ev sahibi takımın ağırlıklı form puanı
        weighted_home_form_points = (
            home_form_periods['last_3']['form_points'] * weight_last_3 +
            home_form_periods['last_6']['form_points'] * weight_last_6 +
            home_form_periods['last_9']['form_points'] * weight_last_9
        ) / total_weight

        # Deplasman takımının ağırlıklı beklenen gol sayısı
        weighted_away_goals = (
            away_form_periods['last_3']['avg_goals'] * weight_last_3 +
            away_form_periods['last_6']['avg_goals'] * weight_last_6 +
            away_form_periods['last_9']['avg_goals'] * weight_last_9
        ) / total_weight

        # Deplasman takımının ağırlıklı form puanı
        weighted_away_form_points = (
            away_form_periods['last_3']['form_points'] * weight_last_3 +
            away_form_periods['last_6']['form_points'] * weight_last_6 +
            away_form_periods['last_9']['form_points'] * weight_last_9
        ) / total_weight

        # Savunma performansını da hesaba katarak beklenen gol hesaplaması
        weighted_home_conceded = (
            home_form_periods['last_3']['avg_conceded'] * weight_last_3 +
            home_form_periods['last_6']['avg_conceded'] * weight_last_6 +
            home_form_periods['last_9']['avg_conceded'] * weight_last_9
        ) / total_weight

        weighted_away_conceded = (
            away_form_periods['last_3']['avg_conceded'] * weight_last_3 +
            away_form_periods['last_6']['avg_conceded'] * weight_last_6 +
            away_form_periods['last_9']['avg_conceded'] * weight_last_9
        ) / total_weight

        # Bayesyen ve ağırlıklı yaklaşımların birleşimi ile daha gerçekçi beklenen gol hesaplama
        # 1. Bayesyen güncelleme ile elde edilen değerler
        bayesian_home_attack = home_form.get('bayesian', {}).get('home_lambda_scored', self.lig_ortalamasi_ev_gol)
        bayesian_away_defense = away_form.get('bayesian', {}).get('away_lambda_conceded', self.lig_ortalamasi_ev_gol)
        bayesian_away_attack = away_form.get('bayesian', {}).get('away_lambda_scored', self.lig_ortalamasi_deplasman_gol)
        bayesian_home_defense = home_form.get('bayesian', {}).get('home_lambda_conceded', self.lig_ortalamasi_deplasman_gol)

        # 2. Ağırlıklı ortalama ile hesaplanan değerler (mevcut kod)
        weighted_home_attack = home_form.get('home_performance', {}).get('weighted_avg_goals_scored', weighted_home_goals)
        weighted_away_defense = away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', weighted_away_conceded)
        weighted_away_attack = away_form.get('away_performance', {}).get('weighted_avg_goals_scored', weighted_away_goals)
        weighted_home_defense = home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', weighted_home_conceded)

        # 3. İki yaklaşımı birleştir (0.6 Bayesyen + 0.4 Ağırlıklı ortalama)
        combined_home_attack = bayesian_home_attack * 0.6 + weighted_home_attack * 0.4
        combined_away_defense = bayesian_away_defense * 0.6 + weighted_away_defense * 0.4
        combined_away_attack = bayesian_away_attack * 0.6 + weighted_away_attack * 0.4
        combined_home_defense = bayesian_home_defense * 0.6 + weighted_home_defense * 0.4

        # 4. Saldırı ve savunma güçlerini birleştirerek beklenen gol hesapla
        # Ev sahibi takımın gol beklentisinde ev avantajını kullan
        expected_home_goals = (combined_home_attack * 0.7 + combined_away_defense * 0.3) * home_advantage
        # Deplasman takımın gol beklentisinde deplasman avantajını kullan
        expected_away_goals = (combined_away_attack * 0.7 + combined_home_defense * 0.3) * away_advantage
        
        logger.info(f"Ham gol beklentileri: Ev={expected_home_goals:.2f}, Deplasman={expected_away_goals:.2f}")

        # Sinir ağı tahminlerini entegre et (eğer varsa)
        if neural_home_goals > 0 and neural_away_goals > 0:
            # Kombine tahmin: %40 sinir ağı + %60 Bayesyen-Ağırlıklı
            expected_home_goals = expected_home_goals * 0.6 + neural_home_goals * 0.4
            expected_away_goals = expected_away_goals * 0.6 + neural_away_goals * 0.4
            logger.info(f"Sinir ağı entegreli tahminler: Ev {expected_home_goals:.2f} - Deplasman {expected_away_goals:.2f}")

        # Global ortalama değerler (lig ortalamaları) - gerçekçi ortalama değerler kullanma
        global_avg_home_goals = 1.6  # Ev sahibi takımlar için genel ortalama gol (düşürüldü)
        global_avg_away_goals = 1.3  # Deplasman takımları için genel ortalama gol (düşürüldü)

        # Mean Reversion uygula - daha gerçekçi gol beklentileri için parametreleri dengele
        # Son form performansına daha fazla ağırlık ver, global ortalamaya daha az
        phi_home = 0.30  # %30 ağırlık global ortalamaya, %70 ağırlık ev sahibi takım performansına
        phi_away = 0.20  # %20 ağırlık global ortalamaya, %80 ağırlık deplasman takım performansına

        # Farklılaştırılmış mean reversion uygula
        expected_home_goals = (1 - phi_home) * expected_home_goals + phi_home * global_avg_home_goals
        expected_away_goals = (1 - phi_away) * expected_away_goals + phi_away * global_avg_away_goals

        # Form farkını daha hassas bir şekilde hesaplama 
        # Katsayıyı azalttık, böylece yüksek form farkı sonuçları abartmayacak
        weighted_home_form_points = home_form.get('home_performance', {}).get('weighted_form_points', weighted_home_form_points)
        weighted_away_form_points = away_form.get('away_performance', {}).get('weighted_form_points', weighted_away_form_points)

        form_diff_home = max(-0.15, min(0.15, 0.05 * (weighted_home_form_points - weighted_away_form_points)))
        form_diff_away = max(-0.15, min(0.15, 0.05 * (weighted_away_form_points - weighted_home_form_points)))

        expected_home_goals = expected_home_goals * (1 + form_diff_home)
        expected_away_goals = expected_away_goals * (1 + form_diff_away)

        # Minimum değerler daha gerçekçi olarak ayarlanıyor, daha düşük minimum değerler
        expected_home_goals = max(0.8, expected_home_goals)
        expected_away_goals = max(0.7, expected_away_goals)

        # Form faktörlerini son 5 maç gol performansına daha fazla ağırlık vererek hesapla
        # Son 5 maçtaki ortalama gol sayılarını kullan
        recent_home_goals_avg = sum(match.get('goals_scored', 0) for match in home_match_data[:5]) / 5 if len(home_match_data) >= 5 else weighted_home_goals
        recent_away_goals_avg = sum(match.get('goals_scored', 0) for match in away_match_data[:5]) / 5 if len(away_match_data) >= 5 else weighted_away_goals
        
        # Son 5 maçtaki gol performansını form faktörüne daha fazla yansıt
        home_recent_factor = recent_home_goals_avg / max(1.0, self.lig_ortalamasi_ev_gol)
        away_recent_factor = recent_away_goals_avg / max(1.0, self.lig_ortalamasi_deplasman_gol)
        
        # Form faktörlerini hesapla - son 5 maç performansını %60 ağırlıkla dahil et
        home_form_factor = min(1.5, (0.4 * (0.7 + weighted_home_form_points * 0.6) + 0.6 * home_recent_factor) * min(1.05, home_advantage))
        away_form_factor = min(1.5, (0.4 * (0.8 + weighted_away_form_points * 0.9) + 0.6 * away_recent_factor))
        
        logger.info(f"Son 5 maç analizi: Ev {recent_home_goals_avg:.2f} gol/maç, Deplasman {recent_away_goals_avg:.2f} gol/maç")
        logger.info(f"Form faktörleri: Ev {home_form_factor:.2f}, Deplasman {away_form_factor:.2f}")

        # Gol dağılımları
        all_home_goals = []
        all_away_goals = []

        # Her iki takımın da gol atma olasılıklarını daha dengeli hesaplama
        p_home_scores = 1 - np.exp(-(expected_home_goals * 1.0 * home_form_factor))
        p_away_scores = 1 - np.exp(-(expected_away_goals * 1.05 * away_form_factor))

        # Beklenen toplam gol - daha dengeli toplam gol hesaplaması
        expected_total_goals = expected_home_goals * home_form_factor * 1.0 + expected_away_goals * away_form_factor * 1.05

        # Beklenen gol sayıları (initial estimations) - daha dengeli başlangıç değerleri
        avg_home_goals = expected_home_goals * (home_form_factor * 1.0)
        avg_away_goals = expected_away_goals * (away_form_factor * 1.05)

        # Monte Carlo simülasyonu için ek değişkenler
        exact_scores = {}  # Kesin skor tahminleri için
        half_time_results = {"HOME_WIN": 0, "DRAW": 0, "AWAY_WIN": 0}  # İlk yarı sonuçları
        full_time_results = {"HOME_WIN": 0, "DRAW": 0, "AWAY_WIN": 0}  # Maç sonu sonuçları
        half_time_full_time = {}  # İlk yarı/maç sonu kombinasyonları
        first_goal_home = 0  # İlk golü ev sahibi takımın atma sayısı
        first_goal_away = 0  # İlk golü deplasman takımının atma sayısı
        no_goal = 0  # Golsüz maç sayısı

        # Kart ve korner tahminleri için
        cards_under_3_5 = 0
        cards_over_3_5 = 0
        corners_under_9_5 = 0
        corners_over_9_5 = 0

        # Gol zamanlaması için
        first_goal_timing = {
            "1-15": 0, "16-30": 0, "31-45": 0, 
            "46-60": 0, "61-75": 0, "76-90": 0, "No Goal": 0
        }

        # Monte Carlo simülasyonu
        for _ in range(simulations):
            # Negatif binomial dağılımını yaklaşık olarak simüle et
            # Poisson dağılımından daha fazla varyasyon gösterir ve gerçek gol dağılımlarını daha iyi temsil eder

            # Negatif binomial parametreleri hesapla
            # Poisson'a göre daha fazla varyasyona izin verir, özellikle yüksek skorlarda
            # r (başarı sayısı) ve p (başarı olasılığı) parametreleri ile tanımlanır

            # Standart sapma, ortalamadan %20 daha yüksek olacak şekilde ayarla (overdispersion)
            home_std_dev = np.sqrt(avg_home_goals * 1.2) if avg_home_goals > 0 else 0.2
            away_std_dev = np.sqrt(avg_away_goals * 1.2) if avg_away_goals > 0 else 0.2

            # Negatif binomial için r ve p hesapla (yaklaşık olarak)
            # Normal Poisson için: variance = mean, Negatif binomial için: variance = mean + (mean^2/r)
            home_r = max(1.0, avg_home_goals / 0.2) if avg_home_goals > 0 else 1.0
            away_r = max(1.0, avg_away_goals / 0.2) if avg_away_goals > 0 else 1.0

            home_p = home_r / (home_r + avg_home_goals)
            away_p = away_r / (away_r + avg_away_goals)

            # Farklı dağılımları daha dengeli kullan
            # Daha fazla çeşitlilik için random_selector ile dağılım seç
            random_selector = np.random.random()

            # Ev sahibi skoru dağılımı - Poisson dağılımına daha fazla ağırlık vererek gol beklentilerine uyumluluğu artır
            if random_selector < 0.7:  # %70 şans - Poisson dağılımına daha yüksek ağırlık
                home_score = np.random.poisson(avg_home_goals)
            else:
                # Negatif binomial dağılımı daha fazla varyasyon sağlar ama daha az ağırlıkta
                try:
                    home_score = np.random.negative_binomial(home_r, home_p)
                except ValueError:
                    home_score = np.random.poisson(avg_home_goals * 1.05)  # Daha düşük düzeltme faktörü
                    
                # Çok aşırı değerleri sınırla
                if home_score > int(avg_home_goals * 3):
                    home_score = np.random.poisson(avg_home_goals)

            # Deplasman skoru dağılımı - Poisson dağılımına daha fazla ağırlık vererek gol beklentilerine uyumluluğu artır
            if random_selector < 0.7:  # %70 şans - Poisson dağılımına daha yüksek ağırlık
                away_score = np.random.poisson(avg_away_goals)
            else:
                # Negatif binomial dağılımı daha fazla varyasyon sağlar ama daha az ağırlıkta
                try:
                    away_score = np.random.negative_binomial(away_r, away_p)
                except ValueError:
                    away_score = np.random.poisson(avg_away_goals * 1.05)  # Daha düşük düzeltme faktörü
                    
                # Çok aşırı değerleri sınırla
                if away_score > int(avg_away_goals * 3):
                    away_score = np.random.poisson(avg_away_goals)

            all_home_goals.append(home_score)
            all_away_goals.append(away_score)

            # Kesin skor tahmini
            exact_score_key = f"{home_score}-{away_score}"
            exact_scores[exact_score_key] = exact_scores.get(exact_score_key, 0) + 1

            # Maç sonucu
            if home_score > away_score:
                home_wins += 1
                full_time_results["HOME_WIN"] += 1
            elif home_score < away_score:
                away_wins += 1
                full_time_results["AWAY_WIN"] += 1
            else:
                draws += 1
                full_time_results["DRAW"] += 1

            # İlk yarı simülasyonu - ilk yarı gollerinin yaklaşık %40'ı atılır
            first_half_home_mean = avg_home_goals * 0.4
            first_half_away_mean = avg_away_goals * 0.4

            first_half_home = np.random.poisson(first_half_home_mean)
            first_half_away = np.random.poisson(first_half_away_mean)

            # İlk yarı sonucu
            if first_half_home > first_half_away:
                half_time_results["HOME_WIN"] += 1
                half_time_key = "HOME_WIN"
            elif first_half_home < first_half_away:
                half_time_results["AWAY_WIN"] += 1
                half_time_key = "AWAY_WIN"
            else:
                half_time_results["DRAW"] += 1
                half_time_key = "DRAW"

            # Maç sonu sonucu
            if home_score > away_score:
                full_time_key = "HOME_WIN"
            elif home_score < away_score:
                full_time_key = "AWAY_WIN"
            else:
                full_time_key = "DRAW"

            # İlk yarı/maç sonu kombinasyonu
            ht_ft_key = f"{half_time_key}/{full_time_key}"
            half_time_full_time[ht_ft_key] = half_time_full_time.get(ht_ft_key, 0) + 1

            # İlk golü kim attı
            total_goals = home_score + away_score
            if total_goals == 0:
                no_goal += 1
            else:
                # İlk golü atma olasılığı hesapla
                p_home_first = avg_home_goals / (avg_home_goals + avg_away_goals) if (avg_home_goals + avg_away_goals) > 0 else 0.5

                if np.random.random() < p_home_first and home_score > 0:
                    first_goal_home += 1
                elif away_score > 0:
                    first_goal_away += 1

            # Gol zamanlaması simülasyonu
            if total_goals == 0:
                first_goal_timing["No Goal"] += 1
            else:
                # Gol zamanlamasını simüle et - genellikle ikinci yarıda daha fazla gol olur
                timing_weights = [0.15, 0.15, 0.15, 0.17, 0.18, 0.20]  # Zamanlamalar için ağırlıklar
                timing_ranges = ["1-15", "16-30", "31-45", "46-60", "61-75", "76-90"]

                first_goal_timing[np.random.choice(timing_ranges, p=[w/sum(timing_weights) for w in timing_weights])] += 1

            # İki takım da gol attı mı
            if home_score > 0 and away_score > 0:
                both_teams_scored += 1

            # Toplam gol sayısı 2.5'tan fazla mı
            total_goals = home_score + away_score
            if total_goals > 2.5:
                over_2_5_goals += 1

            # Toplam gol sayısı 3.5'tan fazla mı
            if total_goals > 3.5:
                over_3_5_goals += 1

            # Kart sayısı simülasyonu
            # Kart sayısı maçın gerginliğine ve gol farkına bağlıdır
            tension_factor = 1.0
            if abs(home_score - away_score) <= 1:  # Yakın maçlarda daha fazla kart
                tension_factor = 1.3
            elif total_goals > 3:  # Çok gollü maçlarda genelde daha az kart
                tension_factor = 0.9

            # Ortalama kart sayısı yaklaşık 3.5
            avg_cards = 3.5 * tension_factor
            cards = np.random.poisson(avg_cards)

            if cards <= 3.5:
                cards_under_3_5 += 1
            else:
                cards_over_3_5 += 1

            # Korner sayısı simülasyonu
            # Korner sayısı takımların hücum gücüne bağlıdır
            attack_factor = (avg_home_goals + avg_away_goals) / 2.5  # Lig ortalamasına göre normalizasyon
            avg_corners = 10 * attack_factor
            corners = np.random.poisson(avg_corners)

            if corners <= 9.5:
                corners_under_9_5 += 1
            else:
                corners_over_9_5 += 1

        # Olasılıkları hesapla
        home_win_prob = home_wins / simulations
        away_win_prob = away_wins / simulations
        draw_prob = draws / simulations
        both_teams_scored_prob = both_teams_scored / simulations
        over_2_5_goals_prob = over_2_5_goals / simulations
        over_3_5_goals_prob = over_3_5_goals / simulations

        # Gelişmiş tahminler için olasılıklar
        cards_over_3_5_prob = cards_over_3_5 / simulations
        corners_over_9_5_prob = corners_over_9_5 / simulations

        # Beraberlik olasılığını yükseltme - kesin skor dağılımına göre ayarlama
        # Hesaplanan en olası kesin skor X-X formunda ise (berabere) beraberlik olasılığını arttır
        top_exact_scores = sorted(exact_scores.items(), key=lambda x: x[1], reverse=True)[:3]

        for score, count in top_exact_scores:
            if '-' in score:
                home_score, away_score = map(int, score.split('-'))
                if home_score == away_score:  # Berabere skor
                    # Skor berabere ve ilk 3 olası skor içindeyse beraberlik olasılığını yükselt
                    score_prob = count / simulations
                    if score_prob > 0.05:  # %5'ten fazla olasılıkla gözüken beraberlik skoru
                        # Beraberlik olasılığını artır - skor olasılığına göre ağırlıklandır
                        adjustment = min(0.25, score_prob * 2)  # Max %25 artış
                        draw_prob = min(0.95, draw_prob * (1 + adjustment))
                        # Diğer olasılıkları azalt ve yeniden normalize et
                        total_win_prob = home_win_prob + away_win_prob
                        if total_win_prob > 0:
                            reduction_factor = (1 - draw_prob) / total_win_prob
                            home_win_prob *= reduction_factor
                            away_win_prob *= reduction_factor
                        logger.info(f"Skor bazlı düzeltme: {score} skoru için beraberlik olasılığı artırıldı")

        # En olası kesin skor - skorları çeşitlendirme
        # En yüksek olasılıklı 3 skoru al ve bunlardan birini seç
        top_3_scores = sorted(exact_scores.items(), key=lambda x: x[1], reverse=True)[:3]

        # Eğer top 3 skor içinde 1-0 varsa ve bu en yüksek olasılıklı skorsa
        # ve takımların gol ortalamaları yeteri kadar yüksekse, alternatif skor seç
        if len(top_3_scores) >= 2 and top_3_scores[0][0] == '1-0' and (avg_home_goals > 1.3 or avg_away_goals > 1.0):
            # İkinci en yüksek olasılıklı skoru kullan
            most_likely_score = top_3_scores[1]
        else:
            most_likely_score = top_3_scores[0]

        most_likely_score_prob = most_likely_score[1] / simulations

        # İlk yarı/maç sonu en olası kombinasyon
        most_likely_ht_ft = max(half_time_full_time.items(), key=lambda x: x[1]) if half_time_full_time else ("DRAW/DRAW", 0)
        most_likely_ht_ft_prob = most_likely_ht_ft[1] / simulations if half_time_full_time else 0

        # İlk golün zamanlaması
        most_likely_first_goal_time = max(first_goal_timing.items(), key=lambda x: x[1])
        most_likely_first_goal_time_prob = most_likely_first_goal_time[1] / simulations

        # İlk golü atan takım
        first_goal_home_prob = first_goal_home / simulations if (first_goal_home + first_goal_away + no_goal) > 0 else 0
        first_goal_away_prob = first_goal_away / simulations if (first_goal_home + first_goal_away + no_goal) > 0 else 0
        no_goal_prob = no_goal / simulations

        # Beklenen gol sayıları (final estimations) - form faktörünün etkisini daha da azalt
        # avg_home_goals ve avg_away_goals zaten daha önce tanımlandı, burada sadece güncelleniyor
        avg_home_goals = expected_home_goals * (home_form_factor * 0.85)
        avg_away_goals = expected_away_goals * (away_form_factor * 0.85)

        # Aşırı yüksek tahminleri düzeltmek için gelişmiş yöntemler

        # Son 3, 5 ve 10 maçın gerçek gol ortalamalarını hesapla
        home_recent_avg_goals = {}
        away_recent_avg_goals = {}
        periods = [3, 5, 10]

        for period in periods:
            # Ev sahibi için
            home_matches_count = min(period, len(home_match_data))
            if home_matches_count > 0:
                home_recent_avg_goals[period] = sum(match.get('goals_scored', 0) for match in home_match_data[:home_matches_count]) / home_matches_count
            else:
                home_recent_avg_goals[period] = self.lig_ortalamasi_ev_gol

            # Deplasman için
            away_matches_count = min(period, len(away_match_data))
            if away_matches_count > 0:
                away_recent_avg_goals[period] = sum(match.get('goals_scored', 0) for match in away_match_data[:away_matches_count]) / away_matches_count
            else:
                away_recent_avg_goals[period] = self.lig_ortalamasi_deplasman_gol

        # Son maçların ortalaması ile genel lig ortalamasını karşılaştır
        home_avg_deviation = (home_recent_avg_goals[3] / self.lig_ortalamasi_ev_gol) * 0.5 + \
                            (home_recent_avg_goals[5] / self.lig_ortalamasi_ev_gol) * 0.3 + \
                            (home_recent_avg_goals[10] / self.lig_ortalamasi_ev_gol) * 0.2

        away_avg_deviation = (away_recent_avg_goals[3] / self.lig_ortalamasi_deplasman_gol) * 0.5 + \
                            (away_recent_avg_goals[5] / self.lig_ortalamasi_deplasman_gol) * 0.3 + \
                            (away_recent_avg_goals[10] / self.lig_ortalamasi_deplasman_gol) * 0.2

        # Sapma değerini sınırla (çok aşırı değerleri engelle)
        home_avg_deviation = min(1.5, max(0.7, home_avg_deviation))
        away_avg_deviation = min(1.5, max(0.7, away_avg_deviation))

        # Z-skor bazlı normalizasyon için takım gol dağılımlarını hesapla
        # Standart sapma hesapla (son 10 maçta)
        home_std_dev = np.std([match.get('goals_scored', 0) for match in home_match_data[:10]]) if len(home_match_data) >= 10 else 1.0
        away_std_dev = np.std([match.get('goals_scored', 0) for match in away_match_data[:10]]) if len(away_match_data) >= 10 else 0.8

        # Savunma gücü değerlendirmesi - rakip takımın savunma istatistikleri
        home_defense_strength = away_form.get('home_performance', {}).get('weighted_avg_goals_conceded', weighted_away_conceded)
        away_defense_strength = home_form.get('away_performance', {}).get('weighted_avg_goals_conceded', weighted_home_conceded)

        # Savunma gücünü lig ortalamasıyla karşılaştır
        home_defense_factor = home_defense_strength / self.lig_ortalamasi_deplasman_gol
        away_defense_factor = away_defense_strength / self.lig_ortalamasi_ev_gol

        # Gol tahminlerini sapma oranı ile düzelt
        avg_home_goals = avg_home_goals * home_avg_deviation * (1.0 + 0.2 * (1.0 - min(1.5, away_defense_factor)))
        avg_away_goals = avg_away_goals * away_avg_deviation * (1.0 + 0.2 * (1.0 - min(1.5, home_defense_factor)))

        # Limit fonksiyonu - logaritmik düzeltme
        def limit_high_values(value, threshold, scaling_factor=0.3):
            if value <= threshold:
                return value
            else:
                return threshold + scaling_factor * np.log1p(value - threshold)

        # Ortalama gol performansına göre takımları sınıflandır (aşırı yüksek tahminleri daha sıkı sınırla)
        home_is_high_scoring = home_recent_avg_goals[5] > 2.0
        away_is_high_scoring = away_recent_avg_goals[5] > 1.5

        # Yüksek gol atan takımlar için daha esnek, düşük gol atan takımlar için daha sıkı sınırlar
        # Ancak genel olarak daha yüksek tahminlere izin ver
        home_threshold = 3.0 if home_is_high_scoring else 2.7
        away_threshold = 2.5 if away_is_high_scoring else 2.2

        # Ev sahibi gol tahminlerini sınırla - daha yumuşak sınırlama için scaling factor artırıldı
        avg_home_goals = limit_high_values(avg_home_goals, home_threshold, 0.5)

        # Deplasman gol tahminlerini sınırla - daha yumuşak sınırlama için scaling factor artırıldı
        avg_away_goals = limit_high_values(avg_away_goals, away_threshold, 0.45)

        # Gerçek dünya istatistiklerine göre maksimum sınırlar - daha dengeli değerler
        home_max = 3.2 if home_is_high_scoring else 3.0
        away_max = 3.2 if away_is_high_scoring else 2.8

        if avg_home_goals > home_max:
            avg_home_goals = home_max + ((avg_home_goals - home_max) * 0.25)

        if avg_away_goals > away_max:
            avg_away_goals = away_max + ((avg_away_goals - away_max) * 0.25)

        # Minimum değerler için daha dengeli alt sınırlar belirle
        # Ev sahibi için daha düşük minimum değer kullanarak zayıf takımları daha doğru yansıt
        avg_home_goals = max(0.8, avg_home_goals)
        avg_away_goals = max(0.7, avg_away_goals)

        # Standart sapma hesapla - Poisson dağılımında standart sapma, ortalamanın kareköküdür
        std_dev_home = np.sqrt(avg_home_goals)  
        std_dev_away = np.sqrt(avg_away_goals)

        # KG VAR/YOK mantığını daha akıllı bir şekilde hesaplayalım
        # Eğer iki takımın da beklenen gol sayısı yüksekse, KG VAR VAR olasılığı daha yüksek olmalı
        kg_var_theoretical_prob = p_home_scores * p_away_scores  # Bağımsız olasılıklar çarpımı

        # Simülasyon sonuçları ile teorik hesaplamalar arasında denge kuralım
        kg_var_adjusted_prob = 0.65 * both_teams_scored_prob + 0.35 * kg_var_theoretical_prob

        # Son 5 karşılaşmada iki takım da gol attıysa KG VAR olasılığını artır
        kg_var_recent_matches = sum(1 for match in home_form.get('recent_match_data', [])[:5] if match.get('goals_scored', 0) > 0 and match.get('goals_conceded', 0) > 0)
        kg_var_recent_matches += sum(1 for match in away_form.get('recent_match_data', [])[:5] if match.get('goals_scored', 0) > 0 and match.get('goals_conceded', 0) > 0)

        if kg_var_recent_matches >= 5:  # Son maçlarda KG VAR eğilimi varsa
            kg_var_adjusted_prob = max(kg_var_adjusted_prob, 0.70)  # En az %70 olasılık

        # 2.5 ve 3.5 gol için teorik olasılıklar (Poisson kümülatif dağılım fonksiyonu)
        # P(X > 2.5) = 1 - P(X ≤ 2) where X ~ Poisson(lambda)
        lambda_total = expected_total_goals
        p_under_25_theoretical = np.exp(-lambda_total) * (1 + lambda_total + (lambda_total**2)/2)
        p_over_25_theoretical = 1 - p_under_25_theoretical

        # 3.5 gol için
        p_under_35_theoretical = p_under_25_theoretical + np.exp(-lambda_total) * (lambda_total**3)/6
        p_over_35_theoretical = 1 - p_under_35_theoretical

        # Simülasyon ve teorik hesaplamalar arasında denge kurma
        # Simülasyon sonuçlarına daha fazla ağırlık veriyoruz (ÜST tahminleri için)
        over_25_adjusted_prob = 0.7 * over_2_5_goals_prob + 0.3 * p_over_25_theoretical
        over_35_adjusted_prob = 0.7 * over_3_5_goals_prob + 0.3 * p_over_35_theoretical

        # Bahis tahminlerini hazırla - korner ve kart tahminlerini çıkararak basitleştir
        bet_predictions = {
            'match_result': self._get_most_likely_outcome(home_win_prob, draw_prob, away_win_prob),
            'both_teams_to_score': 'YES' if kg_var_adjusted_prob > 0.5 else 'NO',
            'over_2_5_goals': 'YES' if over_25_adjusted_prob > 0.5 else 'NO',
            'over_3_5_goals': 'YES' if over_35_adjusted_prob > 0.5 else 'NO',
            'exact_score': most_likely_score[0],
            'half_time_full_time': most_likely_ht_ft[0],
            'first_goal_time': most_likely_first_goal_time[0],
            'first_goal_team': 'HOME' if first_goal_home_prob > first_goal_away_prob and first_goal_home_prob > no_goal_prob else
                              'AWAY' if first_goal_away_prob > first_goal_home_prob and first_goal_away_prob > no_goal_prob else 'NO GOAL'
            # Korner ve kart tahminleri kaldırıldı
        }

        # Son maçların gol ortalamalarını sadece gerekli değerlerle kaydet
        recent_goals_average = {
            'home': home_recent_avg_goals.get(5, 0),
            'away': away_recent_avg_goals.get(5, 0)
        }

        # Gol beklentilerine göre KG VAR/YOK, ÜST/ALT tahminlerini ayarla ve tutarlılığı sağla
        expected_total_goals = avg_home_goals + avg_away_goals
        
        # KG VAR/YOK tahmini - geliştirilmiş mantık
        # Hem takımların gol beklentilerini hem de gol atma olasılıklarını hesaba kat
        p_home_scores_at_least_one = 1 - np.exp(-avg_home_goals)
        p_away_scores_at_least_one = 1 - np.exp(-avg_away_goals)
        
        # İki takımın da en az 1 gol atma olasılığı
        p_both_teams_score = p_home_scores_at_least_one * p_away_scores_at_least_one
        
        # Daha dengeli karar verme - geçmiş veriler de dikkate alınıyor
        if p_both_teams_score > 0.55 or (avg_home_goals > 1.0 and avg_away_goals > 0.9):
            bet_predictions['both_teams_to_score'] = 'YES'
            kg_var_adjusted_prob = max(kg_var_adjusted_prob, 0.75)
        else:
            # KG YOK tahmini
            bet_predictions['both_teams_to_score'] = 'NO'
            kg_var_adjusted_prob = min(kg_var_adjusted_prob, 0.3)
        
        # 2.5 ÜST/ALT tahmini - Poisson dağılımı temelli
        # P(X > 2.5) = 1 - P(X ≤ 2) = 1 - (e^(-λ) + λe^(-λ) + (λ^2/2)e^(-λ))
        # Burada λ = beklenen toplam gol sayısı
        p_under_25 = np.exp(-expected_total_goals) * (1 + expected_total_goals + (expected_total_goals**2)/2)
        p_over_25 = 1 - p_under_25
        
        # Daha tutarlı 2.5 ÜST/ALT tahmini
        if p_over_25 > 0.52 or expected_total_goals > 2.6:
            bet_predictions['over_2_5_goals'] = 'YES'
            over_25_adjusted_prob = max(over_25_adjusted_prob, 0.7)
        else:
            bet_predictions['over_2_5_goals'] = 'NO'
            over_25_adjusted_prob = min(over_25_adjusted_prob, 0.3)
        
        # 3.5 ÜST/ALT tahmini - Poisson dağılımı temelli
        # P(X > 3.5) = 1 - P(X ≤ 3) = 1 - (e^(-λ) + λe^(-λ) + (λ^2/2)e^(-λ) + (λ^3/6)e^(-λ))
        p_under_35 = p_under_25 + np.exp(-expected_total_goals) * (expected_total_goals**3)/6
        p_over_35 = 1 - p_under_35
        
        # Daha tutarlı 3.5 ÜST/ALT tahmini
        if p_over_35 > 0.48 or expected_total_goals > 3.4:
            bet_predictions['over_3_5_goals'] = 'YES'
            over_35_adjusted_prob = max(over_35_adjusted_prob, 0.65)
        else:
            bet_predictions['over_3_5_goals'] = 'NO'
            over_35_adjusted_prob = min(over_35_adjusted_prob, 0.3)
            
        # KG VAR/YOK ve 2.5 ÜST/ALT, 3.5 ÜST/ALT arasındaki tutarlılığı sağla
        # Eğer 2.5 ALT ve KG VAR tahmini varsa, maç sonu olasılıklarını da kontrol et
        if bet_predictions['over_2_5_goals'] == 'NO' and bet_predictions['both_teams_to_score'] == 'YES':
            # Bu kombinasyon genellikle 1-1 skoru gerektirir, beraberlik olasılığı artmalı
            draw_prob = max(draw_prob, home_win_prob, away_win_prob) + 0.1
            # Olasılıkları yeniden normalize et
            total = draw_prob + home_win_prob + away_win_prob
            draw_prob = draw_prob / total
            home_win_prob = home_win_prob / total
            away_win_prob = away_win_prob / total
            
            # Beraberlik olasılığı çok yüksekse, beraberlik sonucunu öner
            if draw_prob > 0.5:
                bet_predictions['match_result'] = 'DRAW'
        
        # Eğer 3.5 ÜST tahmini varsa, 2.5 ÜST de olmalı
        if bet_predictions['over_3_5_goals'] == 'YES' and bet_predictions['over_2_5_goals'] == 'NO':
            bet_predictions['over_2_5_goals'] = 'YES'
            over_25_adjusted_prob = max(over_25_adjusted_prob, 0.8)

        # En yüksek olasılıklı tahmini belirle - korner ve kart tahminlerini çıkardık
        bet_probabilities = {
            'match_result': max(home_win_prob, draw_prob, away_win_prob),
            'both_teams_to_score': max(kg_var_adjusted_prob, 1 - kg_var_adjusted_prob),
            'over_2_5_goals': max(over_25_adjusted_prob, 1 - over_25_adjusted_prob),
            'over_3_5_goals': max(over_35_adjusted_prob, 1 - over_35_adjusted_prob),
            'exact_score': most_likely_score_prob,
            'half_time_full_time': most_likely_ht_ft_prob,
            'first_goal_time': most_likely_first_goal_time_prob,
            'first_goal_team': max(first_goal_home_prob, first_goal_away_prob, no_goal_prob)
        }

        # Tahminler arasındaki mantık tutarlılığını kontrol et - geliştirilmiş versiyon
        
        # İlk adım: Gol beklentilerine göre olasılıkları ayarlama
        # Doğrudan gol beklentisi farkından MS olasılıklarını hesapla
        goal_diff = avg_home_goals - avg_away_goals
        
        # Gol beklentileri ve maç sonucu arasındaki ilişkiyi daha doğru kur
        # Gol farkı formülü: sigmoid benzeri bir yaklaşım kullan
        def sigmoid_like(x, scale=1.5):
            return 1 / (1 + np.exp(-scale * x))
        
        # Gol farkına göre ev sahibi ve deplasman kazanma olasılıklarını hesapla
        base_home_win = sigmoid_like(goal_diff)
        base_away_win = sigmoid_like(-goal_diff)
        
        # Beraberlik olasılığını gol farkının mutlak değerine göre ayarla
        # Gol farkı az ise beraberlik olasılığı yüksek olmalı
        base_draw = 1 - (sigmoid_like(abs(goal_diff), scale=2.5))
        
        # Olasılıkları normalize et
        total = base_home_win + base_draw + base_away_win
        norm_home_win = base_home_win / total
        norm_draw = base_draw / total  
        norm_away_win = base_away_win / total
        
        # Mevcut simülasyon olasılıkları ile hesaplanan olasılıklar arasında denge kur
        # %70 simülasyon sonuçlarına, %30 gol beklentisi temelli matematiksel hesaplamaya güven
        blend_factor = 0.3
        home_win_prob = (1 - blend_factor) * home_win_prob + blend_factor * norm_home_win
        draw_prob = (1 - blend_factor) * draw_prob + blend_factor * norm_draw  
        away_win_prob = (1 - blend_factor) * away_win_prob + blend_factor * norm_away_win
        
        logger.info(f"Gol beklentilerine göre MS olasılıkları ayarlandı: MS1={home_win_prob:.2f}, X={draw_prob:.2f}, MS2={away_win_prob:.2f}")
        
        # İkinci adım: Kesin skor ile diğer tahminleri uyumlu hale getir
        # Önce en olası kesin skoru belirle
        top_3_scores = sorted(exact_scores.items(), key=lambda x: x[1], reverse=True)[:5]
        
        # En olası skorları analiz et
        score_probabilities = {}
        for score, count in top_3_scores:
            score_probabilities[score] = count / simulations
            
        logger.info(f"En olası skorlar ve olasılıkları: {score_probabilities}")
        
        # Doğrudan beklenen gol değerlerinden kesin skoru hesapla
        most_expected_home_score = round(avg_home_goals)
        most_expected_away_score = round(avg_away_goals)
        expected_score = f"{most_expected_home_score}-{most_expected_away_score}"
        
        # Top 5 skorları alarak olasılık dağılımını daha iyi anla
        top_5_scores = sorted(exact_scores.items(), key=lambda x: x[1], reverse=True)[:5]
        logger.info(f"En olası 5 skor ve olasılıkları: {[(s, round(c/simulations*100, 2)) for s, c in top_5_scores]}")
        logger.info(f"Beklenen goller: Ev={avg_home_goals:.2f}, Deplasman={avg_away_goals:.2f}")
        
        # Kesin skor olasılıklarını daha doğru değerlendirmek için histogram
        score_histogram = {}
        for h in range(6):  # 0-5 gol
            for a in range(6):  # 0-5 gol
                score = f"{h}-{a}"
                score_histogram[score] = exact_scores.get(score, 0) / simulations
                
        # En yüksek olasılıklı skorları gruplandırarak analiz et
        same_outcome_scores = {
            "HOME_WIN": {},
            "DRAW": {},
            "AWAY_WIN": {}
        }
        
        for score, prob in score_histogram.items():
            if '-' in score:
                h, a = map(int, score.split('-'))
                if h > a:
                    same_outcome_scores["HOME_WIN"][score] = prob
                elif h == a:
                    same_outcome_scores["DRAW"][score] = prob
                else:
                    same_outcome_scores["AWAY_WIN"][score] = prob
        
        # Maç sonucu olasılıklarına göre en olası skoru belirlemek
        most_likely_outcome = self._get_most_likely_outcome(home_win_prob, draw_prob, away_win_prob)
        top_scores_by_outcome = sorted(same_outcome_scores[most_likely_outcome].items(), key=lambda x: x[1], reverse=True)
        
        # Eğer en olası maç sonucu için skorlar varsa, bunları değerlendir
        if top_scores_by_outcome:
            logger.info(f"En olası maç sonucu {most_likely_outcome} için olası skorlar: {[(s, round(p*100, 2)) for s, p in top_scores_by_outcome[:3]]}")
        
        # Düşük gol beklentisinde (1'in altında) form durumuna göre karar ver
        # Ev sahibi takım için
        if avg_home_goals < 1.0:
            # Form ve ev sahibi avantajını değerlendir
            home_form_points = home_form.get('home_performance', {}).get('weighted_form_points', 0.3)
            
            # Son 3 maçtaki gol ortalamasına da bak
            recent_goals_avg = 0
            goals_in_last_matches = 0
            match_count = 0
            
            for match in home_match_data[:3]:
                if match.get('is_home', False):  # Sadece ev sahibi maçlarını dikkate al
                    goals_in_last_matches += match.get('goals_scored', 0)
                    match_count += 1
            
            if match_count > 0:
                recent_goals_avg = goals_in_last_matches / match_count
            
            # Form iyi, ev sahibi avantajı varsa veya son maçlarda gol attıysa
            if (home_form_points > 0.5 and home_advantage > 1.02) or weighted_home_form_points > 0.7 or recent_goals_avg > 0.7:
                # Form iyiyse veya son maçlarda gol attıysa daha yüksek gol olasılığı
                rounded_home_goals = 1
                logger.info(f"Ev sahibi gol beklentisi 1'in altında ({avg_home_goals:.2f}) ama form iyi veya son maçlarda gol ortalaması {recent_goals_avg:.2f}, 1 gol veriliyor")
            else:
                # Form kötüyse ve son maçlarda çok az gol attıysa daha düşük gol olasılığı
                rounded_home_goals = 0
                logger.info(f"Ev sahibi gol beklentisi 1'in altında ({avg_home_goals:.2f}), form düşük ve son maçlarda gol ortalaması {recent_goals_avg:.2f}, 0 gol veriliyor")
        else:
            # Direk yuvarlamak yerine form ve avantajları dikkate al
            if avg_home_goals > 2.5 and avg_home_goals < 3.0:
                # 2.5-3.0 arası değerlerde
                if weighted_home_form_points > 0.6 or home_advantage > 1.1:
                    # Form veya ev avantajı iyiyse 3'e yuvarla
                    rounded_home_goals = 3
                    logger.info(f"Ev sahibi gol beklentisi 2.5-3.0 arasında ({avg_home_goals:.2f}) ve form iyi, 3 gol veriliyor")
                else:
                    # Yoksa 2'ye yuvarla
                    rounded_home_goals = 2
                    logger.info(f"Ev sahibi gol beklentisi 2.5-3.0 arasında ({avg_home_goals:.2f}) ama form düşük, 2 gol veriliyor")
            elif avg_home_goals > 1.5 and avg_home_goals < 2.0:
                # 1.5-2.0 arası değerlerde
                if weighted_home_form_points > 0.5 or home_advantage > 1.05:
                    # Form veya ev avantajı iyiyse 2'ye yuvarla
                    rounded_home_goals = 2
                    logger.info(f"Ev sahibi gol beklentisi 1.5-2.0 arasında ({avg_home_goals:.2f}) ve form iyi, 2 gol veriliyor")
                else:
                    # Yoksa 1'e yuvarla
                    rounded_home_goals = 1
                    logger.info(f"Ev sahibi gol beklentisi 1.5-2.0 arasında ({avg_home_goals:.2f}) ama form düşük, 1 gol veriliyor")
            else:
                # Diğer değerlerde yuvarla
                rounded_home_goals = int(round(avg_home_goals))
                
        # Deplasman takımı için
        if avg_away_goals < 1.0:
            # Form ve deplasman performansını değerlendir
            away_form_points = away_form.get('away_performance', {}).get('weighted_form_points', 0.3)
            
            # Son 3 maçtaki gol ortalamasına da bak
            recent_goals_avg = 0
            goals_in_last_matches = 0
            match_count = 0
            
            for match in away_match_data[:3]:
                if not match.get('is_home', True):  # Sadece deplasman maçlarını dikkate al
                    goals_in_last_matches += match.get('goals_scored', 0)
                    match_count += 1
            
            if match_count > 0:
                recent_goals_avg = goals_in_last_matches / match_count
                
            # Son 5 maçta ev sahibine karşı gol atma oranı
            goals_vs_similar = []
            for match in away_match_data[:10]:
                opponent_home_form = None
                opponent_id = None
                if not match.get('is_home', True) and match.get('goals_scored', 0) > 0:
                    # Benzer güçte rakiplere karşı gol atma durumu
                    goals_vs_similar.append(match.get('goals_scored', 0))
            
            avg_vs_similar = sum(goals_vs_similar) / len(goals_vs_similar) if goals_vs_similar else 0
            
            # Form iyi, deplasman avantajı varsa veya son maçlarda gol attıysa
            if (away_form_points > 0.6 and away_advantage > 1.05) or weighted_away_form_points > 0.8 or recent_goals_avg > 0.7 or avg_vs_similar > 0.8:
                # Form iyiyse veya benzer rakiplere karşı gol attıysa daha yüksek gol olasılığı
                rounded_away_goals = 1
                logger.info(f"Deplasman gol beklentisi 1'in altında ({avg_away_goals:.2f}) ama form iyi veya son maçlarda gol ortalaması {recent_goals_avg:.2f}, benzer rakiplere karşı {avg_vs_similar:.2f}, 1 gol veriliyor")
            else:
                # Form kötüyse ve son maçlarda çok az gol attıysa daha düşük gol olasılığı
                rounded_away_goals = 0
                logger.info(f"Deplasman gol beklentisi 1'in altında ({avg_away_goals:.2f}), form düşük ve son maçlarda gol ortalaması {recent_goals_avg:.2f}, 0 gol veriliyor")
        else:
            # Değiştirilmiş yuvarlama mantığı - beklenen gol sayısını daha doğru yansıtmak için
            # 1.8 ve üstü değerleri için daha hassas yuvarlama
            if avg_away_goals >= 1.8:
                # Tam sayıya uzaklığı hesapla
                decimal_part = avg_away_goals - int(avg_away_goals)
                
                # 0.35'ten büyükse bir üst sayıya yuvarla
                if decimal_part >= 0.35:
                    rounded_away_goals = int(avg_away_goals) + 1
                    logger.info(f"Deplasman gol beklentisi {avg_away_goals:.2f}, {decimal_part:.2f} ondalık kısmı 0.35'ten büyük olduğu için {rounded_away_goals} olarak yuvarlandı")
                else:
                    rounded_away_goals = int(avg_away_goals)
                    logger.info(f"Deplasman gol beklentisi {avg_away_goals:.2f}, {decimal_part:.2f} ondalık kısmı 0.35'ten küçük olduğu için {rounded_away_goals} olarak yuvarlandı")
            # 1.5-1.8 arası değerlerde form durumuna göre karar ver
            elif avg_away_goals > 1.5 and avg_away_goals < 1.8:
                if weighted_away_form_points > 0.55 or away_advantage > 1.1 or recent_goals_avg > 1.5:
                    # Form iyi veya son maçlarda gol ortalaması yüksekse 2'ye yuvarla
                    rounded_away_goals = 2
                    logger.info(f"Deplasman gol beklentisi 1.5-1.8 arasında ({avg_away_goals:.2f}) ve form iyi, 2 gol veriliyor")
                else:
                    # Form zayıfsa 1'e yuvarla
                    rounded_away_goals = 1
                    logger.info(f"Deplasman gol beklentisi 1.5-1.8 arasında ({avg_away_goals:.2f}) ama form düşük, 1 gol veriliyor")
            else:
                # Diğer değerlerde standart yuvarlama işlemi kullan
                rounded_away_goals = round(avg_away_goals)
                logger.info(f"Deplasman gol beklentisi {avg_away_goals:.2f}, standart yuvarlamayla {rounded_away_goals} olarak belirlendi")
                
        expected_score = f"{rounded_home_goals}-{rounded_away_goals}"
        
        # Önce beklenen skoru kullan, ancak olasılık çok düşükse top 5 içinden seç
        expected_score_prob = exact_scores.get(expected_score, 0) / simulations
        logger.info(f"Beklenen skor {expected_score} olasılığı: %{round(expected_score_prob*100, 2)}")
        
        # Beklenen skoru birkaç farklı yöntemle değerlendir
        expected_score_methods = {
            "rounded_mean": expected_score,  # Beklenen gollerin yuvarlanması
            "simulation_top": top_5_scores[0][0] if top_5_scores else expected_score,  # Monte Carlo simülasyonundan en yüksek olasılıklı skor
            "outcome_based": "" # En olası maç sonucuna göre en olası skor (aşağıda doldurulacak)
        }
        
        # Maç sonucu tahminini kullanarak skor belirle
        if most_likely_outcome == "HOME_WIN":
            outcome_scores = sorted(same_outcome_scores["HOME_WIN"].items(), key=lambda x: x[1], reverse=True)
            expected_score_methods["outcome_based"] = outcome_scores[0][0] if outcome_scores else expected_score
        elif most_likely_outcome == "DRAW":
            outcome_scores = sorted(same_outcome_scores["DRAW"].items(), key=lambda x: x[1], reverse=True)
            expected_score_methods["outcome_based"] = outcome_scores[0][0] if outcome_scores else expected_score
        else:  # AWAY_WIN
            outcome_scores = sorted(same_outcome_scores["AWAY_WIN"].items(), key=lambda x: x[1], reverse=True)
            expected_score_methods["outcome_based"] = outcome_scores[0][0] if outcome_scores else expected_score
            
        # Takımların gücünü değerlendirerek skor seçme stratejisini belirle
        home_strength = weighted_home_form_points
        away_strength = weighted_away_form_points
        is_balanced_match = abs(home_strength - away_strength) < 0.2
        is_high_scoring_home = home_recent_avg_goals.get(5, 0) > 1.8
        is_high_scoring_away = away_recent_avg_goals.get(5, 0) > 1.5
        
        # Varsayılan olarak outcome_based yaklaşımı kullan
        most_likely_score = expected_score_methods["outcome_based"]
        
        # Özel durumları ele al
        if is_balanced_match:
            # Dengeli maçlarda simulasyon sonuçlarına daha fazla güven
            if expected_score_prob < 0.07:  # Beklenen skor olasılığı düşükse
                simulation_score = expected_score_methods["simulation_top"]
                simulation_prob = score_histogram.get(simulation_score, 0)
                
                if simulation_prob > expected_score_prob * 1.5:
                    most_likely_score = simulation_score
                    logger.info(f"Dengeli maç, simulasyon tahmini tercih edildi: {simulation_score} (olasılık: %{round(simulation_prob*100, 2)})")
                else:
                    most_likely_score = expected_score_methods["outcome_based"]
                    logger.info(f"Dengeli maç, maç sonucu bazlı tahmin tercih edildi: {most_likely_score}")
        elif is_high_scoring_home and is_high_scoring_away:
            # İki takım da çok gol atıyorsa, daha yüksek skorlu bir tahmin yap
            high_scoring_candidates = []
            for score, prob in score_histogram.items():
                if '-' in score:
                    h, a = map(int, score.split('-'))
                    if h + a >= 3 and prob > 0.05:  # En az 3 gol ve %5 üzeri olasılık
                        high_scoring_candidates.append((score, prob))
            
            if high_scoring_candidates:
                high_scoring_candidates.sort(key=lambda x: x[1], reverse=True)
                most_likely_score = high_scoring_candidates[0][0]
                logger.info(f"Yüksek skorlu maç beklentisi: {most_likely_score} seçildi (olasılık: %{round(high_scoring_candidates[0][1]*100, 2)})")
            else:
                # Yeterli aday yoksa, beklenen skoru kullan
                most_likely_score = expected_score
        else:
            # Takımların gücüne ve maç sonucu tahminlerine dayalı skorları değerlendir
            outcome_score = expected_score_methods["outcome_based"]
            outcome_prob = score_histogram.get(outcome_score, 0)
            
            if outcome_prob > expected_score_prob or outcome_prob > 0.08:  # %8'den yüksek olasılık
                most_likely_score = outcome_score
                logger.info(f"Maç sonucu bazlı tahmin tercih edildi: {outcome_score} (olasılık: %{round(outcome_prob*100, 2)})")
            else:
                # Beklenen goller daha güvenilir, beklenen skoru kullan
                most_likely_score = expected_score
                logger.info(f"Beklenen gollere dayanarak {expected_score} skoru seçildi (olasılık: %{round(expected_score_prob*100, 2)})")
        
        # Özel durum: Eğer goller çok yakınsa ve beraberlik olasılığı yüksekse, beraberlik skorunu değerlendir
        if abs(avg_home_goals - avg_away_goals) < 0.3 and draw_prob > 0.25:
            # Olası beraberlik skorunu hesapla
            likely_draw_score = int(round((avg_home_goals + avg_away_goals) / 2))
            draw_score = f"{likely_draw_score}-{likely_draw_score}"
            draw_score_prob = exact_scores.get(draw_score, 0) / simulations
            
            if draw_score_prob > 0.1:  # %10'dan yüksek olasılık
                most_likely_score = draw_score
                logger.info(f"Gol beklentileri çok yakın ({avg_home_goals:.2f} vs {avg_away_goals:.2f}) ve beraberlik olasılığı yüksek (%{round(draw_prob*100, 2)}), {draw_score} skoru seçildi")
                
        # Kesin skoru belirle
        bet_predictions['exact_score'] = most_likely_score
        
        # Kesin skor üzerinden maç sonucu, ÜST/ALT ve KG VAR/YOK tahminlerini güncelle
        score_parts = most_likely_score.split('-')
        if len(score_parts) == 2:
            home_score, away_score = int(score_parts[0]), int(score_parts[1])
            total_goals = home_score + away_score
            
            # Gol beklentileri ile skorlar arasındaki uyumu kontrol et
            home_score_diff = abs(home_score - avg_home_goals)
            away_score_diff = abs(away_score - avg_away_goals)
            
            # Skor beklentiler ile uyumlu değilse uyarı logla
            if home_score_diff > 1.0 or away_score_diff > 1.0:
                logger.warning(f"Seçilen skor {most_likely_score} ile gol beklentileri {avg_home_goals:.2f}-{avg_away_goals:.2f} arasında büyük fark var!")
            else:
                logger.info(f"Seçilen skor {most_likely_score} gol beklentilerine {avg_home_goals:.2f}-{avg_away_goals:.2f} yakın ve uyumlu.")
            
            # Maç sonucu - Önce beklenen golleri karşılaştır, sonra skora göre belirle
            # Beklenen gol sayıları arasındaki fark
            expected_goal_diff = avg_home_goals - avg_away_goals
            
            # Skor ile beklenen golleri karşılaştır
            if home_score > away_score:
                # Beklenen gollere göre kontrol et
                if expected_goal_diff >= 0.2:  # Ev sahibinin beklenen golü en az 0.2 fazlaysa makul
                    bet_predictions['match_result'] = 'HOME_WIN'
                    logger.info(f"Ev galibiyet tahmini beklenen gollerle ({expected_goal_diff:.2f}) uyumlu")
                elif expected_goal_diff <= -0.3:  # Deplasman beklenen golleri çok daha yüksekse uyumsuzluk var
                    # Beklenen gol farkı büyükse ve deplasman lehine ise, skor tutarsız olabilir
                    if abs(expected_goal_diff) > 0.5:
                        # Skoru düzeltmeyi değerlendir
                        logger.warning(f"Tutarsız tahmin: Ev galibiyeti skoru ({home_score}-{away_score}) beklenen gollerle ({avg_home_goals:.2f}-{avg_away_goals:.2f}) uyumsuz")
                        
                        # Gerçek beklenen gollere göre düzeltilmiş skor
                        home_score = rounded_home_goals
                        away_score = rounded_away_goals
                        
                        # Düzeltilmiş skora göre sonucu belirle
                        if home_score > away_score:
                            bet_predictions['match_result'] = 'HOME_WIN'
                        elif away_score > home_score:
                            bet_predictions['match_result'] = 'AWAY_WIN'
                        else:
                            bet_predictions['match_result'] = 'DRAW'
                            
                        bet_predictions['exact_score'] = f"{home_score}-{away_score}"
                        logger.info(f"Skor düzeltildi: {bet_predictions['exact_score']} (beklenen goller temel alındı)")
                    else:
                        bet_predictions['match_result'] = 'HOME_WIN'
                else:
                    bet_predictions['match_result'] = 'HOME_WIN'
                
                # Skor farkına göre olasılığı belirle
                goal_diff = home_score - away_score
                
                # Olasılığı beklenen gol farkıyla dengele
                base_prob = 0.5 + (expected_goal_diff * 0.15)  # Beklenen gol farkı artıkça olasılık artar
                
                # Gerçekçi olasılık ayarlaması
                if goal_diff == 1:  # Minimal fark
                    home_win_prob = max(home_win_prob, min(0.65, base_prob))
                elif goal_diff == 2:  # Orta fark
                    home_win_prob = max(home_win_prob, min(0.75, base_prob + 0.1))
                else:  # Büyük fark
                    home_win_prob = max(home_win_prob, min(0.85, base_prob + 0.2))
                    
                # Diğer olasılıkları dengele
                remaining = 1.0 - home_win_prob
                draw_prob = remaining * 0.6
                away_win_prob = remaining * 0.4
                
            elif away_score > home_score:
                # Beklenen gollere göre kontrol et
                if expected_goal_diff <= -0.2:  # Deplasman beklenen golü en az 0.2 fazlaysa makul
                    bet_predictions['match_result'] = 'AWAY_WIN'
                    logger.info(f"Deplasman galibiyet tahmini beklenen gollerle ({-expected_goal_diff:.2f}) uyumlu")
                elif expected_goal_diff >= 0.3:  # Ev sahibi beklenen golleri çok daha yüksekse uyumsuzluk var
                    # Beklenen gol farkı büyükse ve ev sahibi lehine ise, skor tutarsız olabilir
                    if abs(expected_goal_diff) > 0.5:
                        # Skoru düzeltmeyi değerlendir
                        logger.warning(f"Tutarsız tahmin: Deplasman galibiyeti skoru ({home_score}-{away_score}) beklenen gollerle ({avg_home_goals:.2f}-{avg_away_goals:.2f}) uyumsuz")
                        
                        # Gerçek beklenen gollere göre düzeltilmiş skor
                        home_score = rounded_home_goals
                        away_score = rounded_away_goals
                        
                        # Düzeltilmiş skora göre sonucu belirle
                        if home_score > away_score:
                            bet_predictions['match_result'] = 'HOME_WIN'
                        elif away_score > home_score:
                            bet_predictions['match_result'] = 'AWAY_WIN'
                        else:
                            bet_predictions['match_result'] = 'DRAW'
                            
                        bet_predictions['exact_score'] = f"{home_score}-{away_score}"
                        logger.info(f"Skor düzeltildi: {bet_predictions['exact_score']} (beklenen goller temel alındı)")
                    else:
                        bet_predictions['match_result'] = 'AWAY_WIN'
                else:
                    bet_predictions['match_result'] = 'AWAY_WIN'
                
                # Skor farkına göre olasılığı belirle
                goal_diff = away_score - home_score
                
                # Olasılığı beklenen gol farkıyla dengele
                base_prob = 0.5 + (-expected_goal_diff * 0.15)  # Beklenen gol farkı artıkça olasılık artar
                
                # Gerçekçi olasılık ayarlaması
                if goal_diff == 1:  # Minimal fark
                    away_win_prob = max(away_win_prob, min(0.65, base_prob))
                elif goal_diff == 2:  # Orta fark
                    away_win_prob = max(away_win_prob, min(0.75, base_prob + 0.1))
                else:  # Büyük fark
                    away_win_prob = max(away_win_prob, min(0.85, base_prob + 0.2))
                    
                # Diğer olasılıkları dengele
                remaining = 1.0 - away_win_prob
                draw_prob = remaining * 0.6
                home_win_prob = remaining * 0.4
                
            else:
                bet_predictions['match_result'] = 'DRAW'
                
                # Beklenen gollere göre beraberlik olasılığını değerlendir
                if abs(expected_goal_diff) < 0.3:  # Beklenen goller çok yakınsa beraberlik mantıklı
                    logger.info(f"Beraberlik tahmini beklenen gollerle ({abs(expected_goal_diff):.2f} fark) uyumlu")
                else:
                    # Beklenen gol farkı büyükse, beraberlik tahmini şüpheli olabilir
                    logger.warning(f"Dikkat: Beraberlik skoru ({home_score}-{away_score}) beklenen gollerde önemli fark ({expected_goal_diff:.2f}) var")
                
                # Skor yüksekliğine göre olasılığı ayarla (yüksek skorlu beraberlikler daha nadir)
                if total_goals <= 2:  # 0-0, 1-1
                    draw_prob = max(draw_prob, min(0.65, 0.5 + 0.15 * (1 - abs(expected_goal_diff))))
                else:  # 2-2, 3-3, vs. 
                    draw_prob = max(draw_prob, min(0.55, 0.5 + 0.05 * (1 - abs(expected_goal_diff))))
                    
                # Diğer olasılıkları dengele
                remaining = 1.0 - draw_prob
                # Beklenen gol farkına göre kalan olasılıkları dağıt
                if expected_goal_diff > 0:
                    home_win_prob = remaining * 0.7
                    away_win_prob = remaining * 0.3
                else:
                    home_win_prob = remaining * 0.3
                    away_win_prob = remaining * 0.7
            
            # KG VAR/YOK - Daha hassas olasılık belirle
            if home_score > 0 and away_score > 0:
                bet_predictions['both_teams_to_score'] = 'YES'
                
                # Geçmiş maçlardaki KG VAR/YOK oranlarını değerlendir
                kg_var_home_matches = sum(1 for match in home_match_data[:5] if match.get('goals_scored', 0) > 0 and match.get('goals_conceded', 0) > 0)
                kg_var_away_matches = sum(1 for match in away_match_data[:5] if match.get('goals_scored', 0) > 0 and match.get('goals_conceded', 0) > 0)
                kg_var_rate = (kg_var_home_matches + kg_var_away_matches) / 10 if len(home_match_data) >= 5 and len(away_match_data) >= 5 else 0.5
                
                # Gol beklentilerine ve geçmiş KG VAR/YOK oranlarına göre olasılığı ayarla
                if avg_home_goals > 1.5 and avg_away_goals > 1.0:
                    base_prob = 0.90  # Yüksek gol beklentisinde daha yüksek olasılık
                else:
                    base_prob = 0.85  # Kesin skordan biliyoruz
                    
                # Geçmiş maçlardaki KG VAR/YOK oranlarını da dikkate al
                kg_var_adjusted_prob = base_prob * 0.8 + kg_var_rate * 0.2
                logger.info(f"KG VAR tahmini: Geçmiş maçlarda KG VAR oranı: {kg_var_rate:.2f}, ayarlanmış olasılık: {kg_var_adjusted_prob:.2f}")
            else:
                bet_predictions['both_teams_to_score'] = 'NO'
                
                # Geçmiş maçlardaki KG YOK oranlarını değerlendir
                kg_yok_home_matches = sum(1 for match in home_match_data[:5] if match.get('goals_scored', 0) == 0 or match.get('goals_conceded', 0) == 0)
                kg_yok_away_matches = sum(1 for match in away_match_data[:5] if match.get('goals_scored', 0) == 0 or match.get('goals_conceded', 0) == 0)
                kg_yok_rate = (kg_yok_home_matches + kg_yok_away_matches) / 10 if len(home_match_data) >= 5 and len(away_match_data) >= 5 else 0.5
                
                # Gol beklentilerine ve geçmiş KG YOK oranlarına göre olasılığı ayarla
                if avg_home_goals < 1.0 or avg_away_goals < 0.8:
                    base_prob = 0.10  # Düşük gol beklentisinde daha düşük KG VAR olasılığı
                else:
                    base_prob = 0.15  # Kesin skordan biliyoruz
                    
                # Geçmiş maçlardaki KG YOK oranlarını da dikkate al
                kg_var_adjusted_prob = base_prob * 0.8 + (1 - kg_yok_rate) * 0.2
                logger.info(f"KG YOK tahmini: Geçmiş maçlarda KG YOK oranı: {kg_yok_rate:.2f}, ayarlanmış KG VAR olasılığı: {kg_var_adjusted_prob:.2f}")
            
            # 2.5 ÜST/ALT - Daha hassas olasılık belirle
            if total_goals > 2.5:
                bet_predictions['over_2_5_goals'] = 'YES'
                
                # Toplam gol beklentisine göre olasılığı ayarla
                expected_total = avg_home_goals + avg_away_goals
                if expected_total > 3.0:
                    over_25_adjusted_prob = 0.90  # Yüksek toplam gol beklentisinde daha yüksek olasılık
                else:
                    over_25_adjusted_prob = 0.85  # Kesin skordan biliyoruz
            else:
                bet_predictions['over_2_5_goals'] = 'NO'
                
                # Toplam gol beklentisine göre olasılığı ayarla
                expected_total = avg_home_goals + avg_away_goals
                if expected_total < 2.0:
                    over_25_adjusted_prob = 0.10  # Düşük toplam gol beklentisinde daha düşük olasılık
                else:
                    over_25_adjusted_prob = 0.15  # Kesin skordan biliyoruz
            
            # 3.5 ÜST/ALT - Daha hassas olasılık belirle
            if total_goals > 3.5:
                bet_predictions['over_3_5_goals'] = 'YES'
                
                # Toplam gol beklentisine göre olasılığı ayarla
                expected_total = avg_home_goals + avg_away_goals
                if expected_total > 4.0:
                    over_35_adjusted_prob = 0.90  # Çok yüksek toplam gol beklentisinde daha yüksek olasılık
                else:
                    over_35_adjusted_prob = 0.85  # Kesin skordan biliyoruz
            else:
                bet_predictions['over_3_5_goals'] = 'NO'
                
                # Toplam gol beklentisine göre olasılığı ayarla
                expected_total = avg_home_goals + avg_away_goals
                if expected_total < 3.0:
                    over_35_adjusted_prob = 0.10  # Düşük toplam gol beklentisinde daha düşük olasılık
                else:
                    over_35_adjusted_prob = 0.15  # Kesin skordan biliyoruz
            
            logger.info(f"Kesin skor {most_likely_score} (gol beklentileri: {avg_home_goals:.2f}-{avg_away_goals:.2f}) esas alınarak tüm tahminler güncellendi")
        
        # Üçüncü adım: Maç sonucu ile diğer tahminler arasındaki tutarlılığı sağla
        match_result = bet_predictions['match_result']
        
        # 1. 2.5 ALT ve KG VAR arasındaki uyumsuzluk
        if bet_predictions['over_2_5_goals'] == 'NO' and bet_predictions['both_teams_to_score'] == 'YES':
            # İstisnai durum: 1-1 skoru
            if bet_predictions['exact_score'] != '1-1':
                # Hangisinin olasılığı daha yüksekse ona göre düzelt
                if over_25_adjusted_prob > kg_var_adjusted_prob:
                    bet_predictions['both_teams_to_score'] = 'NO'
                    logger.info("Mantık düzeltmesi: 2.5 ALT ve KG VAR uyumsuzluğu - KG YOK olarak güncellendi")
                    # Skoru da güncelle
                    if match_result == 'HOME_WIN':
                        bet_predictions['exact_score'] = '2-0'
                    elif match_result == 'AWAY_WIN':
                        bet_predictions['exact_score'] = '0-2'
                    else:  # DRAW
                        bet_predictions['exact_score'] = '0-0'
                else:
                    bet_predictions['over_2_5_goals'] = 'YES'
                    logger.info("Mantık düzeltmesi: 2.5 ALT ve KG VAR uyumsuzluğu - 2.5 ÜST olarak güncellendi")
                    # Skoru da güncelle
                    if match_result == 'HOME_WIN':
                        bet_predictions['exact_score'] = '2-1'
                    elif match_result == 'AWAY_WIN':
                        bet_predictions['exact_score'] = '1-2'
                    else:  # DRAW
                        bet_predictions['exact_score'] = '1-1'
        
        # 2. MS1/MS2 ve KG YOK arasındaki uyumsuzluk - skor kontrolü
        if (match_result in ['HOME_WIN', 'AWAY_WIN']) and bet_predictions['both_teams_to_score'] == 'NO':
            score_parts = bet_predictions['exact_score'].split('-')
            if len(score_parts) == 2:
                home_score, away_score = int(score_parts[0]), int(score_parts[1])
                if home_score > 0 and away_score > 0:
                    # Tutarsızlık var, düzelt
                    if match_result == 'HOME_WIN':
                        bet_predictions['exact_score'] = f"{home_score}-0"
                    else:  # AWAY_WIN
                        bet_predictions['exact_score'] = f"0-{away_score}"
                    logger.info(f"Mantık düzeltmesi: {match_result} ve KG YOK tutarsızlık - skor güncellendi")
        
        # 3. MS1/MS2 ve KG VAR arasındaki uyumsuzluk - skor kontrolü
        if (match_result in ['HOME_WIN', 'AWAY_WIN']) and bet_predictions['both_teams_to_score'] == 'YES':
            score_parts = bet_predictions['exact_score'].split('-')
            if len(score_parts) == 2:
                home_score, away_score = int(score_parts[0]), int(score_parts[1])
                if home_score == 0 or away_score == 0:
                    # Tutarsızlık var, düzelt
                    if match_result == 'HOME_WIN':
                        bet_predictions['exact_score'] = '2-1'
                    else:  # AWAY_WIN
                        bet_predictions['exact_score'] = '1-2'
                    logger.info(f"Mantık düzeltmesi: {match_result} ve KG VAR tutarsızlık - skor güncellendi")
        
        # 4. DRAW ve skor uyumsuzluğu
        if match_result == 'DRAW':
            score_parts = bet_predictions['exact_score'].split('-')
            if len(score_parts) == 2:
                home_score, away_score = int(score_parts[0]), int(score_parts[1])
                if home_score != away_score:
                    # Beraberlik skoru değil, düzelt
                    if bet_predictions['both_teams_to_score'] == 'YES':
                        bet_predictions['exact_score'] = '1-1'
                    else:
                        bet_predictions['exact_score'] = '0-0'
                    logger.info("Mantık düzeltmesi: DRAW ve skor uyumsuzluğu - skor güncellendi")
        
        # 5. İlk yarı/maç sonu düzeltmesi
        # Kesin skor üzerinden en olası ilk yarı skorunu tahmin et
        score_parts = bet_predictions['exact_score'].split('-')
        if len(score_parts) == 2:
            home_score, away_score = int(score_parts[0]), int(score_parts[1])
            # İlk yarıda genellikle toplam gollerin %40'ı atılır
            expected_ht_home = round(home_score * 0.4)
            expected_ht_away = round(away_score * 0.4)
            
            # İlk yarı sonucu
            ht_result = "DRAW"
            if expected_ht_home > expected_ht_away:
                ht_result = "HOME_WIN"
            elif expected_ht_away > expected_ht_home:
                ht_result = "AWAY_WIN"
            
            # Maç sonu sonucu
            ft_result = bet_predictions['match_result']
            
            # İlk yarı/maç sonu kombinasyonu
            bet_predictions['half_time_full_time'] = f"{ht_result}/{ft_result}"
            most_likely_ht_ft = (bet_predictions['half_time_full_time'], 0)  # Formata uyum için
            most_likely_ht_ft_prob = 0.35  # Tahmini bir değer
            
            logger.info(f"İlk yarı/maç sonu tahmini güncellendi: {bet_predictions['half_time_full_time']}")
        
        # Rakip gücü analizi yap
        opponent_analysis = self.analyze_opponent_strength(home_form, away_form)
        logger.info(f"Rakip gücü analizi: Göreceli güç = {opponent_analysis['relative_strength']:.2f}")
        
        # H2H analizini yap
        h2h_analysis = self.analyze_head_to_head(home_team_id, away_team_id, home_team_name, away_team_name)
        
        if h2h_analysis and h2h_analysis['total_matches'] > 0:
            logger.info(f"H2H analizi: {h2h_analysis['home_wins']}-{h2h_analysis['draws']}-{h2h_analysis['away_wins']} ({h2h_analysis['total_matches']} maç)")
            
            # H2H analizine dayanarak maç sonucu olasılıklarını ayarla
            h2h_home_win_rate = h2h_analysis['home_wins'] / h2h_analysis['total_matches']
            h2h_draw_rate = h2h_analysis['draws'] / h2h_analysis['total_matches']
            h2h_away_win_rate = h2h_analysis['away_wins'] / h2h_analysis['total_matches']
            
            # H2H analizi ile mevcut tahminleri birleştir (20% H2H, 80% mevcut tahmin)
            if h2h_analysis['total_matches'] >= 3:  # En az 3 H2H maç varsa
                h2h_weight = 0.2  # %20 ağırlık
                home_win_prob = home_win_prob * (1 - h2h_weight) + h2h_home_win_rate * h2h_weight
                draw_prob = draw_prob * (1 - h2h_weight) + h2h_draw_rate * h2h_weight
                away_win_prob = away_win_prob * (1 - h2h_weight) + h2h_away_win_rate * h2h_weight
                
                logger.info(f"H2H analizi sonrası MS olasılıkları güncellendi: MS1={home_win_prob:.2f}, X={draw_prob:.2f}, MS2={away_win_prob:.2f}")
            
            # H2H'taki ortalama golleri de değerlendir
            if h2h_analysis['total_matches'] >= 3:  # En az 3 H2H maç varsa
                h2h_goals_weight = 0.15  # %15 ağırlık
                avg_home_goals = avg_home_goals * (1 - h2h_goals_weight) + h2h_analysis['avg_home_goals'] * h2h_goals_weight
                avg_away_goals = avg_away_goals * (1 - h2h_goals_weight) + h2h_analysis['avg_away_goals'] * h2h_goals_weight
                
                logger.info(f"H2H analizi sonrası gol beklentileri güncellendi: Ev={avg_home_goals:.2f}, Deplasman={avg_away_goals:.2f}")
                
                # Kesin skor tahminini güncelle
                if abs(avg_home_goals - avg_away_goals) < 0.3 and most_likely_outcome != "DRAW":
                    # Gol beklentileri yakın ama beraberlik tahmini yoksa, yeniden değerlendir
                    logger.info(f"H2H verilerine göre skor yeniden değerlendiriliyor. Gol beklentileri çok yakın, beraberlik olasılığı arttırılıyor.")
                    draw_prob = max(draw_prob, home_win_prob, away_win_prob) * 1.1
                    home_win_prob = (1 - draw_prob) * (home_win_prob / (home_win_prob + away_win_prob)) if (home_win_prob + away_win_prob) > 0 else 0.25
                    away_win_prob = (1 - draw_prob) * (away_win_prob / (home_win_prob + away_win_prob)) if (home_win_prob + away_win_prob) > 0 else 0.25
                    
                    # Olasılıkları normalize et
                    total = home_win_prob + draw_prob + away_win_prob
                    if total > 0:
                        home_win_prob /= total
                        draw_prob /= total
                        away_win_prob /= total
                        
                    # En olası sonucu güncelle
                    most_likely_outcome = self._get_most_likely_outcome(home_win_prob, draw_prob, away_win_prob)
                    
                    # Kesin skoru güncelle (H2H verisi kullanarak)
                    if most_likely_outcome == "DRAW":
                        if h2h_analysis['avg_home_goals'] > 1.5 and h2h_analysis['avg_away_goals'] > 1.5:
                            most_likely_score = "2-2"  # Yüksek skorlu beraberlik
                        elif h2h_analysis['avg_home_goals'] > 0.8 and h2h_analysis['avg_away_goals'] > 0.8:
                            most_likely_score = "1-1"  # Orta skorlu beraberlik
                        else:
                            most_likely_score = "0-0"  # Düşük skorlu beraberlik
                            
                        logger.info(f"H2H verilerine göre kesin skor güncellendi: {most_likely_score}")
        
        # Rakip analizi sonuçlarına göre skoru güncelle
        if opponent_analysis['relative_strength'] > 0.6:  # Ev sahibi daha güçlüyse
            # Ev sahibi güç farkı fazlaysa ve ev galibiyeti tahmin ediliyorsa skor farkını arttır
            if most_likely_outcome == "HOME_WIN":
                home_score, away_score = map(int, most_likely_score.split('-'))
                if home_score - away_score == 1 and opponent_analysis['home_vs_weak_score'] > 0.7:
                    # Ev sahibi zayıf takımlara karşı güçlüyse skor farkını arttır
                    most_likely_score = f"{home_score+1}-{away_score}"
                    logger.info(f"Rakip analizi sonrası kesin skor güncellendi (ev sahibi daha güçlü): {most_likely_score}")
        elif opponent_analysis['relative_strength'] < 0.4:  # Deplasman daha güçlüyse
            # Deplasman güç farkı fazlaysa ve deplasman galibiyeti tahmin ediliyorsa skor farkını arttır
            if most_likely_outcome == "AWAY_WIN":
                home_score, away_score = map(int, most_likely_score.split('-'))
                if away_score - home_score == 1 and opponent_analysis['away_vs_weak_score'] > 0.7:
                    # Deplasman zayıf takımlara karşı güçlüyse skor farkını arttır
                    most_likely_score = f"{home_score}-{away_score+1}"
                    logger.info(f"Rakip analizi sonrası kesin skor güncellendi (deplasman daha güçlü): {most_likely_score}")
        
        # Son olarak, olasılıkları yeniden normalize et
        total_prob = home_win_prob + draw_prob + away_win_prob
        if total_prob > 0:
            home_win_prob = home_win_prob / total_prob
            draw_prob = draw_prob / total_prob
            away_win_prob = away_win_prob / total_prob

        # En yüksek olasılıklı tahmini bul
        most_confident_bet = max(bet_probabilities, key=bet_probabilities.get)

        # Tahmin sonuçlarını hazırla
        prediction = {
            'match': f"{home_team_name} vs {away_team_name}",
            'home_team': {
                'id': home_team_id,
                'name': home_team_name,
                'form': home_form,
                'form_periods': {
                    'last_3': home_form_periods['last_3'],
                    'last_6': home_form_periods['last_6'],
                    'last_9': home_form_periods['last_9']
                }
            },
            'away_team': {
                'id': away_team_id,
                'name': away_team_name,
                'form': away_form,
                'form_periods': {
                    'last_3': away_form_periods['last_3'],
                    'last_6': away_form_periods['last_6'],
                    'last_9': away_form_periods['last_9']
                }
            },
            'head_to_head': h2h_analysis if h2h_analysis else {
                'home_wins': 0,
                'away_wins': 0,
                'draws': 0, 
                'total_matches': 0,
                'avg_home_goals': 0,
                'avg_away_goals': 0,
                'recent_matches': []
            },
            'opponent_analysis': opponent_analysis,
            'predictions': {
                'home_win_probability': round(home_win_prob * 100, 2),
                'draw_probability': round(draw_prob * 100, 2),
                'away_win_probability': round(away_win_prob * 100, 2),
                'expected_goals': {
                    'home': round(avg_home_goals, 2),
                    'away': round(avg_away_goals, 2)
                },
                'confidence': self._calculate_confidence(home_form, away_form),
                'most_likely_outcome': self._get_most_likely_outcome(home_win_prob, draw_prob, away_win_prob),
                'betting_predictions': {
                    'both_teams_to_score': {
                        'prediction': bet_predictions['both_teams_to_score'],
                        'probability': round(bet_probabilities['both_teams_to_score'] * 100, 2)
                    },
                    'over_2_5_goals': {
                        'prediction': bet_predictions['over_2_5_goals'],
                        'probability': round(bet_probabilities['over_2_5_goals'] * 100, 2)
                    },
                    'over_3_5_goals': {
                        'prediction': bet_predictions['over_3_5_goals'],
                        'probability': round(bet_probabilities['over_3_5_goals'] * 100, 2)
                    },
                    'exact_score': {
                        'prediction': bet_predictions['exact_score'],
                        'probability': round(bet_probabilities['exact_score'] * 100, 2)
                    },
                    'half_time_full_time': {
                        'prediction': bet_predictions['half_time_full_time'],
                        'probability': round(bet_probabilities['half_time_full_time'] * 100, 2)
                    },
                    'first_goal': {
                        'team': bet_predictions['first_goal_team'],
                        'time': bet_predictions['first_goal_time'],
                        'probability': round(bet_probabilities['first_goal_team'] * 100, 2)
                    }
                    # Korner ve kart tahminleri kaldırıldı
                },
                'neural_predictions': {
                    'home_goals': round(neural_home_goals, 2),
                    'away_goals': round(neural_away_goals, 2),
                    'combined_model': {
                        'home_goals': round(expected_home_goals, 2),
                        'away_goals': round(expected_away_goals, 2)
                    }
                },
                'raw_metrics': {
                    'expected_home_goals': round(avg_home_goals, 2),
                    'expected_away_goals': round(avg_away_goals, 2),
                    'p_home_scores': round(p_home_scores * 100, 2),
                    'p_away_scores': round(p_away_scores * 100, 2),
                    'expected_total_goals': round(expected_total_goals, 2),
                    'form_weights': {
                        'last_3_matches': weight_last_3,
                        'last_6_matches': weight_last_6,
                        'last_9_matches': weight_last_9
                    },
                    'weighted_form': {
                        'home_weighted_goals': round(weighted_home_goals, 2),
                        'home_weighted_form': round(weighted_home_form_points, 2),
                        'away_weighted_goals': round(weighted_away_goals, 2),
                        'away_weighted_form': round(weighted_away_form_points, 2)
                    },
                    'bayesian': {
                        'home_attack': round(home_form.get('bayesian', {}).get('home_lambda_scored', 0), 2),
                        'home_defense': round(home_form.get('bayesian', {}).get('home_lambda_conceded', 0), 2),
                        'away_attack': round(away_form.get('bayesian', {}).get('away_lambda_scored', 0), 2),
                        'away_defense': round(away_form.get('bayesian', {}).get('away_lambda_conceded', 0), 2),
                        'prior_home_goals': self.lig_ortalamasi_ev_gol,
                        'prior_away_goals': self.lig_ortalamasi_deplasman_gol
                    },
                    'recent_goals_average': recent_goals_average,
                    'defense_factors': {
                        'home_defense_factor': round(home_defense_factor, 2),
                        'away_defense_factor': round(away_defense_factor, 2)
                    },
                    'z_score_data': {
                        'home_std_dev': round(home_std_dev, 2),
                        'away_std_dev': round(away_std_dev, 2)
                    },
                    'adjusted_thresholds': {
                        'home_threshold': home_threshold,
                        'away_threshold': away_threshold,
                        'home_max': home_max,
                        'away_max': away_max
                    }
                },
                'most_confident_bet': {
                    'market': most_confident_bet,
                    'prediction': bet_predictions[most_confident_bet],
                    'probability': round(bet_probabilities[most_confident_bet] * 100, 2)
                },
                'explanation': {
                    'exact_score': f"Analiz edilen faktörler sonucunda en olası skor {most_likely_score} olarak tahmin edildi. Ev sahibi takımın beklenen gol ortalaması {avg_home_goals:.2f}, deplasman takımının beklenen gol ortalaması {avg_away_goals:.2f}.",
                    'match_result': f"Maç sonucu {self._get_most_likely_outcome(home_win_prob, draw_prob, away_win_prob)} tahmini, ev sahibi (%{round(home_win_prob*100,1)}), beraberlik (%{round(draw_prob*100,1)}) ve deplasman (%{round(away_win_prob*100,1)}) olasılıklarına dayanmaktadır.",
                    'relative_strength': f"Rakip analizi sonucunda, {opponent_analysis['relative_strength'] > 0.5 and home_team_name or away_team_name} göreceli olarak daha güçlü bulundu (güç oranı: {abs(0.5-opponent_analysis['relative_strength'])*2*100:.1f}%).",
                    'head_to_head': f"Geçmiş karşılaşmalarda {h2h_analysis and h2h_analysis['total_matches'] or 0} maç oynandı. Sonuçlar: {h2h_analysis and h2h_analysis['home_wins'] or 0} ev sahibi galibiyeti, {h2h_analysis and h2h_analysis['draws'] or 0} beraberlik, {h2h_analysis and h2h_analysis['away_wins'] or 0} deplasman galibiyeti."
                }
            },
            'timestamp': datetime.now().timestamp(),
            'date_predicted': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

        # Gelişmiş modellerin tahminlerini ekle (varsa) - YENİ: Geliştirilmiş tutarlı entegrasyon
        if use_advanced_models and advanced_prediction:
            # Gelişmiş tahminleri esas al - daha tutarlı yaklaşım
            prediction['predictions']['advanced_models'] = {
                'zero_inflated_poisson': {
                    'expected_goals': advanced_prediction['expected_goals'],
                    'home_win_probability': advanced_prediction['home_win_probability'],
                    'draw_probability': advanced_prediction['draw_probability'],
                    'away_win_probability': advanced_prediction['away_win_probability'],
                    'most_likely_outcome': advanced_prediction['most_likely_outcome'],
                    'most_likely_scores': advanced_prediction['model_details']['top_5_likely_scores'][:3],
                    'zero_zero_probability': advanced_prediction['model_details']['zero_zero_prob']
                },
                'ensemble_predictions': {
                    'home_goals': advanced_prediction['model_details'].get('ensemble_home_goals', 0),
                    'away_goals': advanced_prediction['model_details'].get('ensemble_away_goals', 0)
                }
            }

            # YENİ: Artık gelişmiş tahminlere daha fazla ağırlık ver - tutarlılık için
            # Gelişmiş tahminlere %70, klasik tahminlere %30 ağırlık
            combined_home_goals = (avg_home_goals * 0.3 + advanced_prediction['expected_goals']['home'] * 0.7)
            combined_away_goals = (avg_away_goals * 0.3 + advanced_prediction['expected_goals']['away'] * 0.7)

            # Final tahminleri güncelle
            prediction['predictions']['expected_goals'] = {
                'home': round(combined_home_goals, 2),
                'away': round(combined_away_goals, 2)
            }
            
            # YENİ: Bahis tahminlerini de gelişmiş modelden al eğer mevcutsa - TUTARLILIK için
            if 'betting_predictions' in advanced_prediction:
                adv_betting = advanced_prediction['betting_predictions']
                
                # Eğer gelişmiş model tam bahis tahminleri içeriyorsa bunları kullan
                if all(key in adv_betting for key in ['both_teams_to_score', 'over_2_5_goals', 'exact_score']):
                    logger.info("Bahis tahminleri gelişmiş tutarlı modelden alınıyor")
                    
                    # Kesin skor
                    if 'exact_score' in adv_betting:
                        bet_predictions['exact_score'] = adv_betting['exact_score']['prediction']
                        bet_probabilities['exact_score'] = adv_betting['exact_score']['probability'] / 100
                    
                    # KG VAR/YOK
                    if 'both_teams_to_score' in adv_betting:
                        bet_predictions['both_teams_to_score'] = adv_betting['both_teams_to_score']['prediction']
                        bet_probabilities['both_teams_to_score'] = adv_betting['both_teams_to_score']['probability'] / 100
                    
                    # 2.5 ÜST/ALT
                    if 'over_2_5_goals' in adv_betting:
                        bet_predictions['over_2_5_goals'] = adv_betting['over_2_5_goals']['prediction']
                        bet_probabilities['over_2_5_goals'] = adv_betting['over_2_5_goals']['probability'] / 100
                    
                    # 3.5 ÜST/ALT
                    if 'over_3_5_goals' in adv_betting:
                        bet_predictions['over_3_5_goals'] = adv_betting['over_3_5_goals']['prediction']
                        bet_probabilities['over_3_5_goals'] = adv_betting['over_3_5_goals']['probability'] / 100
                    
                    # Maç sonucu (MS)
                    home_win_prob = advanced_prediction['home_win_probability'] / 100
                    draw_prob = advanced_prediction['draw_probability'] / 100
                    away_win_prob = advanced_prediction['away_win_probability'] / 100
                    
                    # MS tahmini güncelleme
                    prediction['predictions']['home_win_probability'] = advanced_prediction['home_win_probability']
                    prediction['predictions']['draw_probability'] = advanced_prediction['draw_probability']
                    prediction['predictions']['away_win_probability'] = advanced_prediction['away_win_probability']
                    prediction['predictions']['most_likely_outcome'] = advanced_prediction['most_likely_outcome']
                    
                    # İlk yarı/maç sonu
                    if 'half_time_full_time' in adv_betting:
                        bet_predictions['half_time_full_time'] = adv_betting['half_time_full_time']['prediction']
                        bet_probabilities['half_time_full_time'] = adv_betting['half_time_full_time']['probability'] / 100
                    
                    # İlk gol
                    if 'first_goal' in adv_betting:
                        bet_predictions['first_goal_team'] = adv_betting['first_goal']['team']
                        bet_predictions['first_goal_time'] = adv_betting['first_goal']['time']
                        bet_probabilities['first_goal_team'] = adv_betting['first_goal']['probability'] / 100
                        bet_probabilities['first_goal_time'] = adv_betting['first_goal']['probability'] / 100

        # Önbelleğe ekle ve kaydet
        self.predictions_cache[cache_key] = prediction
        self.save_cache()

        return prediction

    def _calculate_confidence(self, home_form, away_form):
        """Tahmin güven seviyesini hesapla"""
        # Takımların oynadığı maç sayısına göre güven hesapla
        home_matches = home_form.get('recent_matches', 0)
        away_matches = away_form.get('recent_matches', 0)

        # Eğer takımlar en az 3 maç oynamışsa daha güvenilir tahmin yapabiliriz
        if home_matches >= 3 and away_matches >= 3:
            confidence = min(home_matches, away_matches) / 5.0  # 5 maç üzerinden normalize et
            return round(min(confidence, 1.0) * 100, 2)  # 0-100 arası değer
        else:
            return round((min(home_matches, away_matches) / 5.0) * 70, 2)  # Daha düşük güven

    def _get_most_likely_outcome(self, home_win_prob, draw_prob, away_win_prob):
        """En olası sonucu belirle"""
        max_prob = max(home_win_prob, draw_prob, away_win_prob)

        if max_prob == home_win_prob:
            return "HOME_WIN"
        elif max_prob == draw_prob:
            return "DRAW"
        else:
            return "AWAY_WIN"

    def collect_training_data(self):
        """Tüm önbellekteki maçları kullanarak sinir ağları için eğitim verisi topla"""
        try:
            home_features = []
            home_targets = []
            away_features = []
            away_targets = []

            # Tahmin önbelleğindeki tüm maçları kontrol et
            for match_key, prediction in self.predictions_cache.items():
                try:
                    if not prediction or 'home_team' not in prediction or 'away_team' not in prediction:
                        continue

                    home_form = prediction['home_team'].get('form')
                    away_form = prediction['away_team'].get('form')

                    if not home_form or not away_form:
                        continue

                    # Hedef (target) değerleri - gerçek maç sonuçları
                    home_expected_goals = prediction['predictions']['expected_goals']['home']
                    away_expected_goals = prediction['predictions']['expected_goals']['away']

                    # Özellik vektörleri oluştur
                    home_data = self.prepare_data_for_neural_network(home_form, is_home=True)
                    away_data = self.prepare_data_for_neural_network(away_form, is_home=False)

                    if home_data is not None and away_data is not None:
                        home_features.append(home_data[0])
                        home_targets.append(home_expected_goals)

                        away_features.append(away_data[0])
                        away_targets.append(away_expected_goals)
                except Exception as e:
                    logger.error(f"Maç verisi işlenirken hata: {str(e)}")
                    continue

            # Eğer yeterli veri varsa sinir ağlarını eğit (daha az örnek ile de eğitim yapabilmek için)
            min_samples = 2  # Daha az örnekle başlayabilmek için eşiği düşürdük
            if len(home_features) >= min_samples and len(away_features) >= min_samples:
                logger.info(f"Sinir ağları için {len(home_features)} ev sahibi, {len(away_features)} deplasman örneği toplandı.")

                # Verileri numpy array'e dönüştür
                X_home = np.array(home_features)
                y_home = np.array(home_targets)
                X_away = np.array(away_features)
                y_away = np.array(away_targets)

                # Ev sahibi modeli eğit
                self.model_home = self.train_neural_network(X_home, y_home, is_home=True)

                # Deplasman modeli eğit
                self.model_away = self.train_neural_network(X_away, y_away, is_home=False)

                return True
            else:
                logger.info(f"Yeterli eğitim verisi bulunamadı, minimum {min_samples} örnek gerekli. "
                          f"Şu anda {len(home_features)} ev sahibi, {len(away_features)} deplasman örneği var.")
                return False
        except Exception as e:
            logger.error(f"Eğitim verisi toplanırken hata: {str(e)}")
            return False

    def analyze_opponent_strength(self, home_form, away_form):
        """Rakip takım gücünü analiz et ve karşılaştır"""
        try:
            # Ev sahibi takımın son maçlarındaki rakipleri analiz et
            home_recent_opponents = []
            for match in home_form.get('recent_match_data', [])[:10]:
                opponent_name = match.get('opponent', '')
                if opponent_name:
                    result = match.get('result', '')
                    is_home = match.get('is_home', False)
                    goals_scored = match.get('goals_scored', 0)
                    goals_conceded = match.get('goals_conceded', 0)
                    
                    opponent_strength = 0.5  # Varsayılan değer
                    
                    # Sonuca göre rakip gücünü tahmin et
                    if result == 'W':
                        opponent_strength = 0.4 if is_home else 0.6  # Deplasmanda kazanmak daha zor
                    elif result == 'D':
                        opponent_strength = 0.5
                    elif result == 'L':
                        opponent_strength = 0.6 if is_home else 0.4  # Evde kaybetmek daha kötü
                    
                    # Gol farkına göre düzelt
                    goal_diff = goals_scored - goals_conceded
                    if result == 'W':
                        if goal_diff >= 3:
                            opponent_strength -= 0.1  # Büyük farkla yenmek rakibin daha zayıf olduğunu gösterir
                        elif goal_diff == 1:
                            opponent_strength += 0.05  # Tek farkla yenmek rakibin daha güçlü olduğunu gösterir
                    elif result == 'L':
                        if abs(goal_diff) >= 3:
                            opponent_strength += 0.1  # Büyük farkla kaybetmek rakibin daha güçlü olduğunu gösterir
                        elif abs(goal_diff) == 1:
                            opponent_strength -= 0.05  # Tek farkla kaybetmek rakibin daha zayıf olduğunu gösterir
                    
                    home_recent_opponents.append({
                        'name': opponent_name,
                        'strength': opponent_strength,
                        'result': result,
                        'is_home': is_home,
                        'goals_scored': goals_scored,
                        'goals_conceded': goals_conceded
                    })
            
            # Deplasman takımının son maçlarındaki rakipleri analiz et
            away_recent_opponents = []
            for match in away_form.get('recent_match_data', [])[:10]:
                opponent_name = match.get('opponent', '')
                if opponent_name:
                    result = match.get('result', '')
                    is_home = match.get('is_home', False)
                    goals_scored = match.get('goals_scored', 0)
                    goals_conceded = match.get('goals_conceded', 0)
                    
                    opponent_strength = 0.5  # Varsayılan değer
                    
                    # Sonuca göre rakip gücünü tahmin et
                    if result == 'W':
                        opponent_strength = 0.4 if is_home else 0.6  # Deplasmanda kazanmak daha zor
                    elif result == 'D':
                        opponent_strength = 0.5
                    elif result == 'L':
                        opponent_strength = 0.6 if is_home else 0.4  # Evde kaybetmek daha kötü
                    
                    # Gol farkına göre düzelt
                    goal_diff = goals_scored - goals_conceded
                    if result == 'W':
                        if goal_diff >= 3:
                            opponent_strength -= 0.1  # Büyük farkla yenmek rakibin daha zayıf olduğunu gösterir
                        elif goal_diff == 1:
                            opponent_strength += 0.05  # Tek farkla yenmek rakibin daha güçlü olduğunu gösterir
                    elif result == 'L':
                        if abs(goal_diff) >= 3:
                            opponent_strength += 0.1  # Büyük farkla kaybetmek rakibin daha güçlü olduğunu gösterir
                        elif abs(goal_diff) == 1:
                            opponent_strength -= 0.05  # Tek farkla kaybetmek rakibin daha zayıf olduğunu gösterir
                    
                    away_recent_opponents.append({
                        'name': opponent_name,
                        'strength': opponent_strength,
                        'result': result,
                        'is_home': is_home,
                        'goals_scored': goals_scored,
                        'goals_conceded': goals_conceded
                    })
            
            # Ortalama rakip güçlerini hesapla
            home_avg_opponent_strength = sum(o['strength'] for o in home_recent_opponents) / len(home_recent_opponents) if home_recent_opponents else 0.5
            away_avg_opponent_strength = sum(o['strength'] for o in away_recent_opponents) / len(away_recent_opponents) if away_recent_opponents else 0.5
            
            # Rakip seviyesine göre performans hesapla
            home_performance_vs_strong = [match for match in home_recent_opponents if match['strength'] > 0.55]
            home_performance_vs_weak = [match for match in home_recent_opponents if match['strength'] < 0.45]
            
            away_performance_vs_strong = [match for match in away_recent_opponents if match['strength'] > 0.55]
            away_performance_vs_weak = [match for match in away_recent_opponents if match['strength'] < 0.45]
            
            # Güçlü rakiplere karşı puan hesapla
            home_points_vs_strong = sum(3 if match['result'] == 'W' else 1 if match['result'] == 'D' else 0 for match in home_performance_vs_strong)
            home_points_vs_weak = sum(3 if match['result'] == 'W' else 1 if match['result'] == 'D' else 0 for match in home_performance_vs_weak)
            
            away_points_vs_strong = sum(3 if match['result'] == 'W' else 1 if match['result'] == 'D' else 0 for match in away_performance_vs_strong)
            away_points_vs_weak = sum(3 if match['result'] == 'W' else 1 if match['result'] == 'D' else 0 for match in away_performance_vs_weak)
            
            # Takımların rakip seviyesine göre performans puanları
            home_vs_strong_score = home_points_vs_strong / (len(home_performance_vs_strong) * 3) if home_performance_vs_strong else 0
            home_vs_weak_score = home_points_vs_weak / (len(home_performance_vs_weak) * 3) if home_performance_vs_weak else 0
            
            away_vs_strong_score = away_points_vs_strong / (len(away_performance_vs_strong) * 3) if away_performance_vs_strong else 0
            away_vs_weak_score = away_points_vs_weak / (len(away_performance_vs_weak) * 3) if away_performance_vs_weak else 0
            
            # Takımların güç karşılaştırması
            relative_strength = 0.5  # Varsayılan eşit güç
            
            if home_avg_opponent_strength > 0.55 and away_avg_opponent_strength < 0.45:
                # Ev sahibi takım daha güçlü rakiplerle oynadıysa
                relative_strength = 0.6
            elif away_avg_opponent_strength > 0.55 and home_avg_opponent_strength < 0.45:
                # Deplasman takımı daha güçlü rakiplerle oynadıysa
                relative_strength = 0.4
            
            # Güçlü rakiplere karşı performans karşılaştırması
            if len(home_performance_vs_strong) > 2 and len(away_performance_vs_strong) > 2:
                if home_vs_strong_score > away_vs_strong_score + 0.2:
                    relative_strength += 0.1
                elif away_vs_strong_score > home_vs_strong_score + 0.2:
                    relative_strength -= 0.1
            
            # Zayıf rakiplere karşı performans karşılaştırması
            if len(home_performance_vs_weak) > 2 and len(away_performance_vs_weak) > 2:
                if home_vs_weak_score > away_vs_weak_score + 0.2:
                    relative_strength += 0.05
                elif away_vs_weak_score > home_vs_weak_score + 0.2:
                    relative_strength -= 0.05
            
            return {
                'home_avg_opponent_strength': home_avg_opponent_strength,
                'away_avg_opponent_strength': away_avg_opponent_strength,
                'home_vs_strong_score': home_vs_strong_score,
                'home_vs_weak_score': home_vs_weak_score,
                'away_vs_strong_score': away_vs_strong_score,
                'away_vs_weak_score': away_vs_weak_score,
                'relative_strength': relative_strength
            }
            
        except Exception as e:
            logger.error(f"Rakip analizi sırasında hata: {str(e)}")
            return {
                'home_avg_opponent_strength': 0.5,
                'away_avg_opponent_strength': 0.5,
                'home_vs_strong_score': 0,
                'home_vs_weak_score': 0,
                'away_vs_strong_score': 0,
                'away_vs_weak_score': 0,
                'relative_strength': 0.5
            }


    def analyze_head_to_head(self, home_team_id, away_team_id, home_team_name, away_team_name):
        """İki takım arasındaki önceki karşılaşmaları analiz et"""
        try:
            # Son 3 yıllık H2H maçları al
            end_date = datetime.now()
            start_date = end_date - timedelta(days=1095)  # Son 3 yıl

            url = "https://apiv3.apifootball.com/"
            params = {
                'action': 'get_H2H',
                'firstTeamId': home_team_id,
                'secondTeamId': away_team_id,
                'from': start_date.strftime('%Y-%m-%d'),
                'to': end_date.strftime('%Y-%m-%d'),
                'APIkey': self.api_key
            }

            response = requests.get(url, params=params)

            if response.status_code != 200:
                logger.error(f"H2H API hatası: {response.status_code}")
                return None

            h2h_data = response.json()

            if not isinstance(h2h_data, dict) or 'firstTeam_VS_secondTeam' not in h2h_data:
                logger.error(f"Beklenmeyen H2H API yanıtı: {h2h_data}")
                return None

            h2h_matches = h2h_data.get('firstTeam_VS_secondTeam', [])

            if not h2h_matches:
                logger.info(f"H2H maç bulunamadı: {home_team_name} vs {away_team_name}")
                return {
                    'home_wins': 0,
                    'away_wins': 0,
                    'draws': 0,
                    'total_matches': 0,
                    'avg_home_goals': 0,
                    'avg_away_goals': 0,
                    'recent_matches': []
                }

            # H2H istatistikleri hesapla
            home_wins = 0
            away_wins = 0
            draws = 0
            total_home_goals = 0
            total_away_goals = 0
            recent_matches = []

            for match in h2h_matches:
                match_home_team = match.get('match_hometeam_name', '')
                match_away_team = match.get('match_awayteam_name', '')
                match_home_score = int(match.get('match_hometeam_score', 0) or 0)
                match_away_score = int(match.get('match_awayteam_score', 0) or 0)
                match_date = match.get('match_date', '')
                match_status = match.get('match_status', '')

                # Sadece tamamlanmış maçları dikkate al
                if match_status not in ['FT', 'AP', 'AET']:
                    continue

                # Maç sonucunu hesapla
                if match_home_team == home_team_name:
                    # Ev sahibi takım aynı
                    if match_home_score > match_away_score:
                        home_wins += 1
                    elif match_home_score < match_away_score:
                        away_wins += 1
                    else:
                        draws += 1

                    total_home_goals += match_home_score
                    total_away_goals += match_away_score
                else:
                    # Takımlar yer değiştirmiş
                    if match_home_score > match_away_score:
                        away_wins += 1
                    elif match_home_score < match_away_score:
                        home_wins += 1
                    else:
                        draws += 1

                    total_home_goals += match_away_score
                    total_away_goals += match_home_score

                # Maç detaylarını ekle
                if match_home_team == home_team_name:
                    result = 'W' if match_home_score > match_away_score else 'D' if match_home_score == match_away_score else 'L'
                    recent_matches.append({
                        'date': match_date,
                        'league': match.get('league_name', ''),
                        'home_score': match_home_score,
                        'away_score': match_away_score,
                        'result': result
                    })
                else:
                    result = 'W' if match_away_score > match_home_score else 'D' if match_home_score == match_away_score else 'L'
                    recent_matches.append({
                        'date': match_date,
                        'league': match.get('league_name', ''),
                        'home_score': match_away_score,
                        'away_score': match_home_score,
                        'result': result
                    })

            # Son maçları tarihe göre sırala
            recent_matches.sort(key=lambda x: x['date'], reverse=True)

            total_matches = home_wins + away_wins + draws
            avg_home_goals = total_home_goals / total_matches if total_matches > 0 else 0
            avg_away_goals = total_away_goals / total_matches if total_matches > 0 else 0

            return {
                'home_wins': home_wins,
                'away_wins': away_wins,
                'draws': draws,
                'total_matches': total_matches,
                'avg_home_goals': avg_home_goals,
                'avg_away_goals': avg_away_goals,
                'recent_matches': recent_matches[:5]  # Sadece son 5 maçı döndür
            }

        except Exception as e:
            logger.error(f"H2H analizi sırasında hata: {str(e)}")
            return None</pre><h1>zip_and_ensemble_predictor.py</h1><pre>
import numpy as np
import os
import pickle
import logging
from scipy.stats import poisson, norm
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AdvancedScorePredictor:
    """Gelişmiş skor tahmin sınıfı"""

    def __init__(self):
        """Gelişmiş tahmin modellerinin başlatılması"""
        self.home_poisson_model = None
        self.away_poisson_model = None
        self.home_ensemble_model = None 
        self.away_ensemble_model = None
        self.scaler = StandardScaler()

        # Modelleri yükle
        self.load_models()
        logger.info("ZIP ve Ensemble tahmin modeli başlatıldı")

    def load_models(self):
        """Kaydedilmiş modelleri yükle veya yeni modeller oluştur"""
        try:
            # Model dosyaları var mı kontrol et
            model_files_exist = all([
                os.path.exists('home_poisson_model.pkl'),
                os.path.exists('away_poisson_model.pkl'),
                os.path.exists('home_ensemble_model.pkl'),
                os.path.exists('away_ensemble_model.pkl')
            ])

            if model_files_exist:
                logger.info("Kaydedilmiş ZIP ve Ensemble model dosyaları yükleniyor...")
                with open('home_poisson_model.pkl', 'rb') as f:
                    self.home_poisson_model = pickle.load(f)

                with open('away_poisson_model.pkl', 'rb') as f:
                    self.away_poisson_model = pickle.load(f)

                with open('home_ensemble_model.pkl', 'rb') as f:
                    self.home_ensemble_model = pickle.load(f)

                with open('away_ensemble_model.pkl', 'rb') as f:
                    self.away_ensemble_model = pickle.load(f)

                logger.info("Gelişmiş tahmin modelleri başarıyla yüklendi")
            else:
                logger.info("Kaydedilmiş model dosyaları bulunamadı, yeni modeller oluşturuluyor...")
                # Varsayılan modeller oluştur
                self.home_poisson_model = {"intercept": -0.5, "home_attack": 0.2, "away_defense": 0.1}
                self.away_poisson_model = {"intercept": -0.8, "away_attack": 0.2, "home_defense": 0.1}

                # Ensemble modeller için
                self.home_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)
                self.away_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)

        except Exception as e:
            logger.error(f"Model yükleme hatası: {e}")
            # Hata durumunda varsayılan modeller oluştur
            self.home_poisson_model = {"intercept": -0.5, "home_attack": 0.2, "away_defense": 0.1}
            self.away_poisson_model = {"intercept": -0.8, "away_attack": 0.2, "home_defense": 0.1}

            # Ensemble modeller için
            self.home_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)
            self.away_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)

    def save_models(self):
        """Modelleri kaydet"""
        try:
            if self.home_poisson_model and self.away_poisson_model and self.home_ensemble_model and self.away_ensemble_model:
                with open('home_poisson_model.pkl', 'wb') as f:
                    pickle.dump(self.home_poisson_model, f)

                with open('away_poisson_model.pkl', 'wb') as f:
                    pickle.dump(self.away_poisson_model, f)

                with open('home_ensemble_model.pkl', 'wb') as f:
                    pickle.dump(self.home_ensemble_model, f)

                with open('away_ensemble_model.pkl', 'wb') as f:
                    pickle.dump(self.away_ensemble_model, f)

                logger.info("Tahmin modelleri başarıyla kaydedildi")
                return True
            else:
                logger.warning("Model dosyaları kaydedilemedi, önce modellerin eğitilmesi gerekiyor")
                return False
        except Exception as e:
            logger.error(f"Model kaydetme hatası: {e}")
            return False

    def train_models(self, cached_predictions):
        """Tahmin modellerini eğit"""
        try:
            # Eğitim verileri için gerekli değişkenleri hazırla
            home_features = []
            home_targets = []
            away_features = []
            away_targets = []

            # Önbellekteki tüm tahminleri dolaş
            for match_key, prediction in cached_predictions.items():
                if not isinstance(prediction, dict) or 'home_team' not in prediction or 'away_team' not in prediction:
                    continue

                home_form = prediction.get('home_team', {}).get('form')
                away_form = prediction.get('away_team', {}).get('form')

                if not home_form or not away_form:
                    continue

                # Gol beklentilerini hedef değerler olarak al
                home_goals_expected = prediction.get('predictions', {}).get('expected_goals', {}).get('home', 0)
                away_goals_expected = prediction.get('predictions', {}).get('expected_goals', {}).get('away', 0)

                # Zero-inflated Poisson için özellikler
                try:
                    # Ev sahibi için özellikler
                    home_attack = home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0)
                    home_defense = home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0)
                    away_attack = away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0)
                    away_defense = away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0)

                    # Ensemble model için daha zengin özellik kümesi
                    # Ev sahibi için
                    home_feature_set = [
                        home_form.get('home_performance', {}).get('avg_goals_scored', 0),
                        home_form.get('home_performance', {}).get('avg_goals_conceded', 0),
                        home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0),
                        home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0),
                        home_form.get('home_performance', {}).get('form_points', 0),
                        home_form.get('bayesian', {}).get('home_lambda_scored', 0),
                        home_form.get('bayesian', {}).get('home_lambda_conceded', 0),
                        home_form.get('recent_matches', 0) / 21,  # Normalize
                        away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0),
                        away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0)
                    ]

                    # Deplasman için
                    away_feature_set = [
                        away_form.get('away_performance', {}).get('avg_goals_scored', 0),
                        away_form.get('away_performance', {}).get('avg_goals_conceded', 0),
                        away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0),
                        away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0),
                        away_form.get('away_performance', {}).get('form_points', 0),
                        away_form.get('bayesian', {}).get('away_lambda_scored', 0),
                        away_form.get('bayesian', {}).get('away_lambda_conceded', 0),
                        away_form.get('recent_matches', 0) / 21,  # Normalize
                        home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0),
                        home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0)
                    ]

                    # Poisson Model için basit özellikler
                    poisson_home_features = {
                        "home_attack": home_attack,
                        "away_defense": away_defense
                    }

                    poisson_away_features = {
                        "away_attack": away_attack,
                        "home_defense": home_defense
                    }

                    # Eğitim verilerine ekle
                    if all(x is not None for x in home_feature_set) and all(x is not None for x in away_feature_set):
                        home_features.append(home_feature_set)
                        home_targets.append(home_goals_expected)

                        away_features.append(away_feature_set)
                        away_targets.append(away_goals_expected)

                except Exception as e:
                    logger.error(f"Maç verisi işlenirken hata: {e}")
                    continue

            # Yeterli veri var mı kontrol et
            if len(home_features) < 10 or len(away_features) < 10:
                logger.warning(f"Yeterli eğitim verisi yok: {len(home_features)} ev sahibi, {len(away_features)} deplasman örneği")
                return False

            # Zero-inflated Poisson modelleri için basit regresyon katsayıları
            # Gerçek bir ZIP fit yerine basit katsayılar kullanıyoruz
            self.home_poisson_model = {
                "intercept": np.mean([t - (0.2 * f[0] + 0.1 * f[9]) for t, f in zip(home_targets, home_features)]),
                "home_attack": 0.2,  # Varsayılan katsayı
                "away_defense": 0.1   # Varsayılan katsayı
            }

            self.away_poisson_model = {
                "intercept": np.mean([t - (0.2 * f[2] + 0.1 * f[9]) for t, f in zip(away_targets, away_features)]),
                "away_attack": 0.2,   # Varsayılan katsayı  
                "home_defense": 0.1    # Varsayılan katsayı
            }

            # Ensemble modelleri eğit
            X_home = np.array(home_features)
            y_home = np.array(home_targets)
            X_away = np.array(away_features)
            y_away = np.array(away_targets)

            # Verileri standartlaştır
            X_home_scaled = self.scaler.fit_transform(X_home)
            X_away_scaled = self.scaler.transform(X_away)

            # Ensemble modelleri eğit
            self.home_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)
            self.home_ensemble_model.fit(X_home_scaled, y_home)

            self.away_ensemble_model = GradientBoostingRegressor(n_estimators=100, random_state=42)
            self.away_ensemble_model.fit(X_away_scaled, y_away)

            logger.info(f"Modeller {len(home_features)} örnek ile başarıyla eğitildi")

            # Modelleri kaydet
            self.save_models()

            return True
        except Exception as e:
            logger.error(f"Model eğitimi sırasında hata: {e}")
            return False

    def calculate_score_probabilities(self, lambda_home, lambda_away, max_goals=6):
        """Poisson dağılımını kullanarak skor olasılıklarını hesapla"""
        from scipy.stats import poisson
        
        # Gerçek skor dağılımları için düzeltme faktörleri
        # Futbol maçlarında gerçekte gözlemlenen skor dağılımları
        # Poisson dağılımından bazı sapmalar gösterir
        correction_factors = {
            "0-0": 1.15,  # 0-0 skoru gerçekte daha sık görünür
            "1-0": 1.10,  # Ev sahibi 1-0 galibiyeti biraz daha sık
            "0-1": 0.95,  # Deplasman 0-1 galibiyeti biraz daha az sık
            "1-1": 1.20,  # 1-1 beraberliği daha sık
            "2-1": 1.05,  # Ev sahibi 2-1 galibiyeti biraz daha sık
            "1-2": 0.95,  # Deplasman 1-2 galibiyeti biraz daha az sık
            "2-0": 1.05,  # 2-0 galibiyeti biraz daha sık
            "0-2": 0.90,  # 0-2 deplasmanı biraz daha az sık
            "2-2": 1.15,  # 2-2 beraberliği daha sık
            "3-0": 1.00,  # 3-0 normal
            "0-3": 0.90,  # 0-3 daha az sık
            "3-1": 1.00,  # 3-1 normal
            "1-3": 0.90,  # 1-3 daha az sık
            "3-2": 1.05,  # 3-2 biraz daha sık
            "2-3": 1.00,  # 2-3 normal
            "3-3": 1.10,  # 3-3 daha sık
            "4-0": 0.95,  # 4-0 biraz daha az sık
            "0-4": 0.85,  # 0-4 daha az sık
            "4-1": 0.95,  # 4-1 biraz daha az sık
            "1-4": 0.85,  # 1-4 daha az sık
            "4-2": 0.95,  # 4-2 biraz daha az sık
            "2-4": 0.90,  # 2-4 daha az sık
            "4-3": 0.95,  # 4-3 biraz daha az sık
            "3-4": 0.90,  # 3-4 daha az sık
            "4-4": 1.05,  # 4-4 biraz daha sık
            "5-0": 0.85,  # 5-0 daha az sık
            "0-5": 0.80,  # 0-5 daha az sık
            "5-1": 0.85,  # 5-1 daha az sık
            "1-5": 0.80,  # 1-5 daha az sık
        }
        
        score_probs = {}
        for h in range(max_goals + 1):
            for a in range(max_goals + 1):
                # Her bir skor kombinasyonunun olasılığını hesapla
                score = f"{h}-{a}"
                prob = poisson.pmf(h, lambda_home) * poisson.pmf(a, lambda_away)
                
                # Gerçek dağılımlara uygun düzeltme faktörü uygula
                if score in correction_factors:
                    prob *= correction_factors[score]
                elif h == a and h > 4:  # Yüksek skorlu beraberlikler
                    prob *= 1.0  # Çok yüksek skorlu beraberlikler için normal faktör
                elif h > 4 and a > 4:  # Çok yüksek skorlu maçlar
                    prob *= 0.8  # Çok yüksek skorlu maçları azalt
                elif h > 4:  # Ev sahibi için çok yüksek skorlar
                    prob *= 0.85
                elif a > 4:  # Deplasman için çok yüksek skorlar
                    prob *= 0.80
                
                score_probs[score] = prob
        
        # Olasılıkları normalize et
        total_prob = sum(score_probs.values())
        if total_prob > 0:
            for score in score_probs:
                score_probs[score] /= total_prob
        
        return score_probs
    
    def predict_match(self, home_form, away_form, cached_predictions=None, model_weight=0.6, simulations=5000):
        """Maç sonucunu tahmin et - Geliştirilmiş tutarlı algoritma"""
        try:
            # Modeller yüklü değilse eğit
            if (not self.home_poisson_model or not self.away_poisson_model or 
                not self.home_ensemble_model or not self.away_ensemble_model) and cached_predictions:
                logger.info("Tahmin modelleri eğitiliyor...")
                self.train_models(cached_predictions)

            # Zero-inflated Poisson için özellik vektörleri
            home_attack = home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0)
            home_defense = home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0)
            away_attack = away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0)
            away_defense = away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0)

            # Zero-inflated Poisson model tahmini
            # log(lambda) = intercept + coef1*x1 + coef2*x2 + ...
            # lambda = exp(intercept + coef1*x1 + coef2*x2 + ...)
            if isinstance(self.home_poisson_model, dict) and isinstance(self.away_poisson_model, dict):
                log_lambda_home = (self.home_poisson_model.get("intercept", 0) + 
                                  self.home_poisson_model.get("home_attack", 0) * home_attack + 
                                  self.home_poisson_model.get("away_defense", 0) * away_defense)

                log_lambda_away = (self.away_poisson_model.get("intercept", 0) + 
                                  self.away_poisson_model.get("away_attack", 0) * away_attack + 
                                  self.away_poisson_model.get("home_defense", 0) * home_defense)

                lambda_home = np.exp(log_lambda_home)
                lambda_away = np.exp(log_lambda_away)
            else:
                # Varsayılan değerler
                lambda_home = 1.5
                lambda_away = 1.0

            # Ensemble model için özellik vektörleri
            home_feature_set = [
                home_form.get('home_performance', {}).get('avg_goals_scored', 0),
                home_form.get('home_performance', {}).get('avg_goals_conceded', 0),
                home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0),
                home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0),
                home_form.get('home_performance', {}).get('form_points', 0),
                home_form.get('bayesian', {}).get('home_lambda_scored', 0),
                home_form.get('bayesian', {}).get('home_lambda_conceded', 0),
                home_form.get('recent_matches', 0) / 21,  # Normalize
                away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0),
                away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0)
            ]

            away_feature_set = [
                away_form.get('away_performance', {}).get('avg_goals_scored', 0),
                away_form.get('away_performance', {}).get('avg_goals_conceded', 0),
                away_form.get('away_performance', {}).get('weighted_avg_goals_scored', 0),
                away_form.get('away_performance', {}).get('weighted_avg_goals_conceded', 0),
                away_form.get('away_performance', {}).get('form_points', 0),
                away_form.get('bayesian', {}).get('away_lambda_scored', 0),
                away_form.get('bayesian', {}).get('away_lambda_conceded', 0),
                away_form.get('recent_matches', 0) / 21,  # Normalize
                home_form.get('home_performance', {}).get('weighted_avg_goals_scored', 0),
                home_form.get('home_performance', {}).get('weighted_avg_goals_conceded', 0)
            ]

            # Ensemble model tahmini
            try:
                X_home = np.array(home_feature_set).reshape(1, -1)
                X_away = np.array(away_feature_set).reshape(1, -1)

                X_home_scaled = self.scaler.transform(X_home)
                X_away_scaled = self.scaler.transform(X_away)

                ensemble_home_goals = float(self.home_ensemble_model.predict(X_home_scaled)[0])
                ensemble_away_goals = float(self.away_ensemble_model.predict(X_away_scaled)[0])

                # Tahmin edilen değerleri pozitif yap
                ensemble_home_goals = max(0.5, ensemble_home_goals)
                ensemble_away_goals = max(0.5, ensemble_away_goals)
            except Exception as e:
                logger.error(f"Ensemble tahmin hatası: {e}")
                ensemble_home_goals = 1.5
                ensemble_away_goals = 1.0

            # Ensemble ve ZIP modellerini birleştir - Modellerin tutarlılığını kontrol et
            # Eğer model tahminleri arasında büyük fark varsa, ağırlıklandırmayı dengele
            if abs(ensemble_home_goals - lambda_home) > 1.5:
                model_weight_home = 0.5  # Eşit ağırlık kullan
                logger.info(f"Ev sahibi için model tahminleri arasında büyük fark: Ensemble={ensemble_home_goals:.2f}, ZIP={lambda_home:.2f}")
            else:
                model_weight_home = model_weight
                
            if abs(ensemble_away_goals - lambda_away) > 1.5:
                model_weight_away = 0.5  # Eşit ağırlık kullan
                logger.info(f"Deplasman için model tahminleri arasında büyük fark: Ensemble={ensemble_away_goals:.2f}, ZIP={lambda_away:.2f}")
            else:
                model_weight_away = model_weight
            
            weighted_home_goals = model_weight_home * ensemble_home_goals + (1 - model_weight_home) * lambda_home
            weighted_away_goals = model_weight_away * ensemble_away_goals + (1 - model_weight_away) * lambda_away

            # Gerçekçi sınırlar uygula - daha dengeli sınırlandırma
            def realistic_limit(value, is_home=True, lower_bound=0.5, upper_bound=3.0):
                if value < lower_bound:
                    return lower_bound
                elif value > upper_bound:
                    # Logaritmik düzeltme: çok yüksek değerleri daha sıkı sınırla (özellikle ev sahibi için)
                    scaling_factor = 0.15 if is_home else 0.2  # Ev sahibi için daha sıkı sınırlama
                    return upper_bound + scaling_factor * np.log1p(value - upper_bound)
                return value

            # Ev sahibi için daha düşük üst sınır (3.0), deplasman için biraz daha yüksek (3.2)
            weighted_home_goals = realistic_limit(weighted_home_goals, is_home=True, upper_bound=3.0)
            weighted_away_goals = realistic_limit(weighted_away_goals, is_home=False, upper_bound=3.2)
            
            logger.info(f"Final gol beklentileri: Ev sahibi={weighted_home_goals:.2f}, Deplasman={weighted_away_goals:.2f}")

            # ---------------------------------------------------------------------
            # YENİ YAKLAŞIM: Poisson dağılımını kullanarak skor olasılık matrisi oluştur
            # ---------------------------------------------------------------------
            
            # Skor olasılıklarını hesapla (Poisson dağılımını kullanarak)
            score_probs = self.calculate_score_probabilities(weighted_home_goals, weighted_away_goals)
            
            # Skoru normalleştir
            total_prob = sum(score_probs.values())
            if total_prob > 0:
                for score in score_probs:
                    score_probs[score] /= total_prob
            
            # En olası 5 skoru bul
            top_scores = sorted(score_probs.items(), key=lambda x: x[1], reverse=True)
            top_5_likely_scores = [(score, round(prob * 100, 2)) for score, prob in top_scores[:5]]
            
            # En olası skor
            most_likely_score = top_scores[0][0]
            most_likely_score_prob = top_scores[0][1]
            
            logger.info(f"En olası skor: {most_likely_score} (olasılık: {most_likely_score_prob*100:.2f}%)")
            
            # MS olasılıklarını doğrudan skor olasılıklarından hesapla
            home_win_probability = sum(prob for score, prob in score_probs.items() 
                                       if int(score.split('-')[0]) > int(score.split('-')[1]))
            
            draw_probability = sum(prob for score, prob in score_probs.items() 
                                  if int(score.split('-')[0]) == int(score.split('-')[1]))
            
            away_win_probability = sum(prob for score, prob in score_probs.items() 
                                      if int(score.split('-')[0]) < int(score.split('-')[1]))
            
            # KG VAR/YOK olasılığını doğrudan skor olasılıklarından hesapla
            kg_var_probability = sum(prob for score, prob in score_probs.items() 
                                    if int(score.split('-')[0]) > 0 and int(score.split('-')[1]) > 0)
            
            # 2.5 ÜST/ALT olasılığını doğrudan skor olasılıklarından hesapla
            over_25_probability = sum(prob for score, prob in score_probs.items() 
                                     if int(score.split('-')[0]) + int(score.split('-')[1]) > 2.5)
            
            # 3.5 ÜST/ALT olasılığını doğrudan skor olasılıklarından hesapla
            over_35_probability = sum(prob for score, prob in score_probs.items() 
                                     if int(score.split('-')[0]) + int(score.split('-')[1]) > 3.5)
            
            # 0-0 skoru olasılığı
            zero_zero_prob = score_probs.get("0-0", 0)
            
            # İlk yarı/maç sonu tahminleri için
            # İlk yarıda genellikle tüm gollerin yaklaşık %40'ı atılır
            home_ht_goals = weighted_home_goals * 0.4
            away_ht_goals = weighted_away_goals * 0.4
            
            ht_score_probs = self.calculate_score_probabilities(home_ht_goals, away_ht_goals)
            
            # İlk yarı sonucu olasılıkları
            ht_home_win_prob = sum(prob for score, prob in ht_score_probs.items() 
                                  if int(score.split('-')[0]) > int(score.split('-')[1]))
            
            ht_draw_prob = sum(prob for score, prob in ht_score_probs.items() 
                              if int(score.split('-')[0]) == int(score.split('-')[1]))
            
            ht_away_win_prob = sum(prob for score, prob in ht_score_probs.items() 
                                  if int(score.split('-')[0]) < int(score.split('-')[1]))
            
            # İlk yarı sonucu
            ht_result = (
                "HOME_WIN" if ht_home_win_prob > max(ht_draw_prob, ht_away_win_prob) else
                "DRAW" if ht_draw_prob > max(ht_home_win_prob, ht_away_win_prob) else
                "AWAY_WIN"
            )
            
            # Maç sonu sonucu
            ft_result = (
                "HOME_WIN" if home_win_probability > max(draw_probability, away_win_probability) else
                "DRAW" if draw_probability > max(home_win_probability, away_win_probability) else
                "AWAY_WIN"
            )
            
            # İlk yarı/maç sonu kombinasyonu
            ht_ft = f"{ht_result}/{ft_result}"
            
            # İlk golü atan takım olasılıkları 
            p_home_first = weighted_home_goals / (weighted_home_goals + weighted_away_goals) if (weighted_home_goals + weighted_away_goals) > 0 else 0.5
            p_away_first = 1 - p_home_first
            p_no_goal = zero_zero_prob
            
            first_goal_team = (
                "HOME" if p_home_first > max(p_away_first, p_no_goal) else
                "AWAY" if p_away_first > max(p_home_first, p_no_goal) else
                "NO GOAL"
            )
            
            # Gol zamanlaması - ağırlıklı olasılıklar
            # Genellikle ikinci yarıda daha fazla gol olur
            time_slots = ["1-15", "16-30", "31-45", "46-60", "61-75", "76-90", "No Goal"]
            time_weights = [0.12, 0.15, 0.13, 0.18, 0.20, 0.22, p_no_goal]  
            normalized_weights = [w/(sum(time_weights)-p_no_goal) * (1-p_no_goal) if i < 6 else w for i, w in enumerate(time_weights)]
            
            first_goal_time = time_slots[normalized_weights.index(max(normalized_weights))]

            # En olası sonuç
            most_likely_outcome = ft_result
            
            # Monte Carlo simülasyonu için - retrospective comparison
            # Skor dağılımlarını simüle et
            home_scores = np.random.poisson(weighted_home_goals, size=simulations)
            away_scores = np.random.poisson(weighted_away_goals, size=simulations)
            
            # Ortalama gol sayısı
            avg_home_goals = np.mean(home_scores)
            avg_away_goals = np.mean(away_scores)

            # Tahmin sonuçları
            prediction = {
                "expected_goals": {
                    "home": round(weighted_home_goals, 2),  # Poisson lambda değeri
                    "away": round(weighted_away_goals, 2)   # Poisson lambda değeri
                },
                "home_win_probability": round(home_win_probability * 100, 2),
                "draw_probability": round(draw_probability * 100, 2),
                "away_win_probability": round(away_win_probability * 100, 2),
                "most_likely_outcome": most_likely_outcome,
                "betting_predictions": {
                    "both_teams_to_score": {
                        "prediction": "YES" if kg_var_probability > 0.5 else "NO",
                        "probability": round(max(kg_var_probability, 1-kg_var_probability) * 100, 2)
                    },
                    "over_2_5_goals": {
                        "prediction": "YES" if over_25_probability > 0.5 else "NO",
                        "probability": round(max(over_25_probability, 1-over_25_probability) * 100, 2)
                    },
                    "over_3_5_goals": {
                        "prediction": "YES" if over_35_probability > 0.5 else "NO",
                        "probability": round(max(over_35_probability, 1-over_35_probability) * 100, 2)
                    },
                    "exact_score": {
                        "prediction": most_likely_score,
                        "probability": round(most_likely_score_prob * 100, 2)
                    },
                    "half_time_full_time": {
                        "prediction": ht_ft,
                        "probability": round(max(ht_home_win_prob, ht_draw_prob, ht_away_win_prob) * 
                                           max(home_win_probability, draw_probability, away_win_probability) * 100, 2)
                    },
                    "first_goal": {
                        "team": first_goal_team,
                        "time": first_goal_time,
                        "probability": round(max(p_home_first, p_away_first, p_no_goal) * 100, 2)
                    }
                },
                "model_details": {
                    "lambda_home": round(lambda_home, 2),
                    "lambda_away": round(lambda_away, 2),
                    "ensemble_home_goals": round(ensemble_home_goals, 2),
                    "ensemble_away_goals": round(ensemble_away_goals, 2),
                    "weighted_home_goals": round(weighted_home_goals, 2),
                    "weighted_away_goals": round(weighted_away_goals, 2),
                    "top_5_likely_scores": top_5_likely_scores,
                    "zero_zero_prob": round(zero_zero_prob * 100, 2),
                    "monte_carlo": {
                        "avg_home_goals": round(avg_home_goals, 2),
                        "avg_away_goals": round(avg_away_goals, 2)
                    }
                },
                "timestamp": datetime.now().timestamp(),
                "date_predicted": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }

            return prediction

        except Exception as e:
            logger.error(f"Gelişmiş tahmin sırasında hata: {e}")
            return None</pre><h1>api_routes.py</h1><pre>
import requests
import json
import os
import logging
from flask import Blueprint, jsonify, request
from datetime import datetime, timedelta

# Logging
logger = logging.getLogger(__name__)

# API Keys
FOOTBALL_DATA_API_KEY = os.environ.get('FOOTBALL_DATA_API_KEY', '668dd03e0aea41b58fce760cdf4eddc8')
API_FOOTBALL_KEY = os.environ.get('API_FOOTBALL_KEY', '2f0c06f149e51424f4c9be24eb70cb8f')

# Blueprint definition
api_v3_bp = Blueprint('api_v3', __name__, url_prefix='/api/v3')

# API Football endpoints
@api_v3_bp.route('/fixtures', methods=['GET'])
def get_fixtures():
    try:
        date = request.args.get('date', datetime.now().strftime("%Y-%m-%d"))
        league = request.args.get('league', '')  # Default to all leagues
        logger.info(f"Fetching fixtures for date: {date}, league: {league if league else 'all leagues'}")

def convert_apifootball_to_standard(matches_data):
    """API-Football verilerini standart formata dönüştür"""
    converted_data = {
        "response": []
    }
    
    for match in matches_data:
        fixture = {
            "fixture": {
                "id": match.get('match_id'),
                "date": match.get('match_date') + 'T' + match.get('match_time') + 'Z',
                "status": {
                    "short": "NS" if match.get('match_status') == '' else match.get('match_status')[:2],
                    "long": match.get('match_status') or 'SCHEDULED'
                },
                "venue": {
                    "name": match.get('match_stadium', '')
                }
            },
            "league": {
                "name": match.get('league_name', ''),
                "logo": match.get('league_logo', '')
            },
            "teams": {
                "home": {
                    "name": match.get('match_hometeam_name', ''),
                    "logo": match.get('team_home_badge', '')
                },
                "away": {
                    "name": match.get('match_awayteam_name', ''),
                    "logo": match.get('team_away_badge', '')
                }
            },
            "goals": {
                "home": match.get('match_hometeam_score', ''),
                "away": match.get('match_awayteam_score', '')
            }
        }
        converted_data["response"].append(fixture)
    
    return converted_data


        timezone = request.args.get('timezone', 'Europe/Istanbul')

        url = "https://v3.football.api-sports.io/fixtures"
        params = {
            "date": date,
            "timezone": timezone
        }

        if league:
            params["league"] = league

        headers = {
            'x-rapidapi-key': API_FOOTBALL_KEY,
            'x-rapidapi-host': 'v3.football.api-sports.io'
        }

        response = requests.get(url, headers=headers, params=params)
        result = response.json()

        if 'errors' in result and result['errors']:
            logger.error(f"API-Football errors: {result['errors']}")
            # If API limit is reached, use football-data.org as fallback
            logger.info("Switching to football-data.org API due to API-Football errors")
            return get_football_data_fixtures(date)

        # Check if the response is valid but empty
        if 'response' in result and len(result['response']) == 0:
            logger.warning(f"API-Football returned empty response for date {date}")
            logger.info("Trying football-data.org API for possible data")
            fallback_result = get_football_data_fixtures(date)
            # If fallback also has no matches, return original empty result
            fallback_data = fallback_result.json if hasattr(fallback_result, 'json') else {}
            if 'response' in fallback_data and len(fallback_data['response']) > 0:
                return fallback_result

        return jsonify(result)
    except Exception as e:
        logger.error(f"Error getting fixtures: {str(e)}")
        return jsonify({"errors": True, "message": str(e)}), 500

# Football-data.org fallback
def get_football_data_fixtures(date):
    try:
        # Önce API-Football ile deneyelim
        url = "https://apiv3.apifootball.com/"
        params = {
            'action': 'get_events',
            'from': date,
            'to': date,
            'APIkey': API_FOOTBALL_KEY
        }
        
        response = requests.get(url, params=params)
        if response.status_code == 200 and isinstance(response.json(), list) and len(response.json()) > 0:
            # API-Football verisi başarıyla alındı, converter'a gönder
            return convert_apifootball_to_standard(response.json())
        
        # API-Football çalışmazsa football-data.org ile devam et
        url = "https://api.football-data.org/v4/matches"
        headers = {'X-Auth-Token': FOOTBALL_DATA_API_KEY}
        params = {"date": date}

        response = requests.get(url, headers=headers, params=params)
        data = response.json()

        # Convert football-data.org format to api-football format
        converted_data = {
            "response": []
        }

        if 'matches' in data:
            for match in data['matches']:
                fixture = {
                    "fixture": {
                        "id": match.get('id'),
                        "date": match.get('utcDate'),
                        "status": {
                            "short": "NS" if match.get('status') == 'SCHEDULED' else match.get('status')[:2],
                            "long": match.get('status')
                        },
                        "venue": {
                            "name": match.get('venue')
                        }
                    },
                    "league": {
                        "name": match.get('competition', {}).get('name'),
                        "logo": match.get('competition', {}).get('emblem')
                    },
                    "teams": {
                        "home": {
                            "name": match.get('homeTeam', {}).get('shortName'),
                            "logo": match.get('homeTeam', {}).get('crest')
                        },
                        "away": {
                            "name": match.get('awayTeam', {}).get('shortName'),
                            "logo": match.get('awayTeam', {}).get('crest')
                        }
                    },
                    "goals": {
                        "home": match.get('score', {}).get('fullTime', {}).get('home'),
                        "away": match.get('score', {}).get('fullTime', {}).get('away')
                    }
                }
                converted_data["response"].append(fixture)

        return jsonify(converted_data)
    except Exception as e:
        logger.error(f"Error getting football-data fixtures: {str(e)}")
        return jsonify({"errors": True, "message": str(e)}), 500

@api_v3_bp.route('/fixtures/team/<int:team_id>', methods=['GET'])
def get_team_matches(team_id):
    try:
        last_count = int(request.args.get('last', 5))  # Son kaç maçı alacağız

        url = "https://v3.football.api-sports.io/fixtures"
        params = {
            "team": team_id,
            "last": last_count
        }

        headers = {
            'x-rapidapi-key': API_FOOTBALL_KEY,
            'x-rapidapi-host': 'v3.football.api-sports.io'
        }

        response = requests.get(url, headers=headers, params=params)
        result = response.json()

        if 'errors' in result and result['errors']:
            logger.error(f"API-Football errors: {result['errors']}")
            # If API limit is reached, use football-data.org as fallback
            return get_football_data_team_matches(team_id)

        # Sadece son n maçı al
        if 'response' in result and len(result['response']) > 0:
            result['response'] = sorted(
                result['response'], 
                key=lambda x: x['fixture']['date'], 
                reverse=True
            )[:last_count]

        return jsonify(result)

    except Exception as e:
        logger.error(f"Error getting team matches: {str(e)}")
        return jsonify({"errors": True, "message": str(e)}), 500

def get_football_data_team_matches(team_id):
    try:
        # Football Data API'de son N maçı almak için bir endpoint yok
        # Bu yüzden tüm maçları çekip filtrelememiz gerekiyor
        url = f"https://api.football-data.org/v4/teams/{team_id}/matches"
        headers = {'X-Auth-Token': FOOTBALL_DATA_API_KEY}
        params = {"status": "FINISHED"}

        response = requests.get(url, headers=headers, params=params)
        data = response.json()

        # Convert football-data.org format to api-football format
        converted_data = {
            "response": []
        }

        if 'matches' in data:
            # En son 5 maçı al
            recent_matches = sorted(data['matches'], key=lambda x: x.get('utcDate'), reverse=True)[:5]

            for match in recent_matches:
                fixture = {
                    "fixture": {
                        "id": match.get('id'),
                        "date": match.get('utcDate'),
                        "status": {
                            "short": match.get('status')[:2],
                            "long": match.get('status')
                        },
                        "venue": {
                            "name": match.get('venue')
                        }
                    },
                    "league": {
                        "name": match.get('competition', {}).get('name'),
                        "logo": match.get('competition', {}).get('emblem')
                    },
                    "teams": {
                        "home": {
                            "name": match.get('homeTeam', {}).get('shortName'),
                            "logo": match.get('homeTeam', {}).get('crest')
                        },
                        "away": {
                            "name": match.get('awayTeam', {}).get('shortName'),
                            "logo": match.get('awayTeam', {}).get('crest')
                        }
                    },
                    "goals": {
                        "home": match.get('score', {}).get('fullTime', {}).get('home'),
                        "away": match.get('score', {}).get('fullTime', {}).get('away')
                    }
                }
                converted_data["response"].append(fixture)

        return jsonify(converted_data)
    except Exception as e:
        logger.error(f"Error getting football-data team matches: {str(e)}")
        return jsonify({"errors": True, "message": str(e)}), 500

@api_v3_bp.route('/status')
def api_status():
    return jsonify({"status": "ok", "message": "API is working"})

@api_v3_bp.route('/api/train-neural-network', methods=['POST'])
def train_neural_network():
    """Sinir ağı modelini eğit (artık otomatik yapılıyor)"""
    try:
        from main import predictor
        success = predictor.collect_training_data()
        if success:
            return jsonify({"success": True, "message": "Sinir ağı modelleri başarıyla eğitildi."})
        else:
            return jsonify({"success": False, "message": "Yeterli veri bulunamadı veya eğitim başarısız oldu. Sinir ağları tahmin sırasında otomatik olarak eğitilecektir."})
    except Exception as e:
        logger.error(f"Sinir ağı eğitimi sırasında hata: {str(e)}")
        return jsonify({"error": str(e)}), 500

@api_v3_bp.route('/api/predict-match/<home_team_id>/<away_team_id>')
def api_v3_predict_match(home_team_id, away_team_id):
    from main import predictor
    home_name = request.args.get('home_name', '')
    away_name = request.args.get('away_name', '')
    force_update = request.args.get('force_update', 'false').lower() == 'true'

    try:
        prediction = predictor.predict_match(home_team_id, away_team_id, home_name, away_name, force_update)
        if prediction:
            # Simplify prediction data by removing complex card and corner predictions
            # to ensure lighter response payload
            if 'predictions' in prediction and 'betting_predictions' in prediction['predictions']:
                betting_predictions = prediction['predictions']['betting_predictions']
                # Remove corner and card predictions to reduce complexity
                if 'cards_over_3_5' in betting_predictions:
                    del betting_predictions['cards_over_3_5']
                if 'corners_over_9_5' in betting_predictions:
                    del betting_predictions['corners_over_9_5']
            return jsonify(prediction)
        else:
            return jsonify({"error": "Tahmin yapılamadı. Yeterli veri bulunmuyor."}), 400
    except Exception as e:
        logger.error(f"API v3 tahmin yapılırken hata: {str(e)}")
        return jsonify({"error": str(e)}), 500

@api_v3_bp.route('/api/advanced-predictions/<home_team_id>/<away_team_id>')
def advanced_predictions(home_team_id, away_team_id):
    """Gelişmiş tahminleri döndüren API endpoint"""
    home_name = request.args.get('home_name', '')
    away_name = request.args.get('away_name', '')
    force_update = request.args.get('force_update', 'false').lower() == 'true'
    prediction_type = request.args.get('type', 'all')  # all, exact_score, ht_ft, cards_corners, goals
    predictor = MatchPredictor()

    try:
        full_prediction = predictor.predict_match(home_team_id, away_team_id, home_name, away_name, force_update)
        
        if not full_prediction:
            return jsonify({"error": "Tahmin yapılamadı. Yeterli veri bulunmuyor."}), 400
            
        # Sadece istenen tahmin türünü döndür
        if prediction_type == 'exact_score':
            return jsonify({
                "match": f"{home_name} vs {away_name}",
                "exact_score": full_prediction['predictions']['betting_predictions']['exact_score']
            })
        elif prediction_type == 'ht_ft':
            return jsonify({
                "match": f"{home_name} vs {away_name}",
                "half_time_full_time": full_prediction['predictions']['betting_predictions']['half_time_full_time']
            })
        elif prediction_type == 'cards_corners':
            return jsonify({
                "match": f"{home_name} vs {away_name}",
                "cards_over_3_5": full_prediction['predictions']['betting_predictions']['cards_over_3_5'],
                "corners_over_9_5": full_prediction['predictions']['betting_predictions']['corners_over_9_5']
            })
        elif prediction_type == 'goals':
            return jsonify({
                "match": f"{home_name} vs {away_name}",
                "first_goal": full_prediction['predictions']['betting_predictions']['first_goal'],
                "over_2_5_goals": full_prediction['predictions']['betting_predictions']['over_2_5_goals'],
                "over_3_5_goals": full_prediction['predictions']['betting_predictions']['over_3_5_goals'],
                "both_teams_to_score": full_prediction['predictions']['betting_predictions']['both_teams_to_score']
            })
        else:
            # Tüm tahminleri döndür
            return jsonify({
                "match": f"{home_name} vs {away_name}",
                "advanced_predictions": full_prediction['predictions']['betting_predictions'],
                "expected_goals": full_prediction['predictions']['expected_goals']
            })
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500</pre><h1>api_football.py</h1><pre>
import requests
import logging

class FootballDataAPI:
    BASE_URL = "https://api.football-data.org/v4"

    def __init__(self, api_key=None):
        self.api_key = api_key or "668dd03e0aea41b58fce760cdf4eddc8"
        self.headers = {
            "X-Auth-Token": self.api_key
        }

    def get_fixtures(self, date=None, league=None, team=None, season=None, unfold_goals=False):
        """Get matches/fixtures based on various parameters"""
        endpoint = f"{self.BASE_URL}/matches"
        params = {}

        if date:
            params["date"] = date
        if league:
            params["competitions"] = league
        if team:
            # If team is provided, switch to team matches endpoint
            endpoint = f"{self.BASE_URL}/teams/{team}/matches"
        if season:
            params["season"] = season

        return self._make_request(endpoint, params, unfold_goals=unfold_goals)

    def get_competitions(self):
        """Get all available competitions"""
        endpoint = f"{self.BASE_URL}/competitions"
        return self._make_request(endpoint)

    def get_competition_standings(self, competition_id, season=None):
        """Get standings for a particular competition"""
        endpoint = f"{self.BASE_URL}/competitions/{competition_id}/standings"
        params = {}
        if season:
            params["season"] = season
        return self._make_request(endpoint, params)

    def get_team_info(self, team_id):
        """Get information about a specific team"""
        endpoint = f"{self.BASE_URL}/teams/{team_id}"
        return self._make_request(endpoint)

    def get_match_info(self, match_id, unfold_goals=False):
        """Get detailed information about a match"""
        endpoint = f"{self.BASE_URL}/matches/{match_id}"
        return self._make_request(endpoint, unfold_goals=unfold_goals)

    def get_scorers(self, competition_id, limit=10):
        """Get top scorers for a competition"""
        endpoint = f"{self.BASE_URL}/competitions/{competition_id}/scorers"
        params = {"limit": limit}
        return self._make_request(endpoint, params)

    def _make_request(self, endpoint, params=None, unfold_goals=False):
        """Make API request with proper error handling"""
        try:
            headers = self.headers.copy()
            if unfold_goals:
                headers["X-Unfold-Goals"] = "true"

            logging.debug(f"API request to: {endpoint} with params: {params}")
            response = requests.get(endpoint, headers=headers, params=params)
            response.raise_for_status()
            result = response.json()
            logging.debug(f"API response status: {response.status_code}")
            return result
        except requests.exceptions.RequestException as e:
            logging.error(f"API request error: {str(e)}")
            return {"error": str(e), "message": "API request failed"}</pre></body></html>
